/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */

import { Program, ProgramError } from '@lorisleiva/js-core';

type ProgramErrorConstructor = new (
  program: Program,
  cause?: Error
) => ProgramError;
const codeToErrorMap: Map<number, ProgramErrorConstructor> = new Map();
const nameToErrorMap: Map<string, ProgramErrorConstructor> = new Map();

/** InstructionUnpackError: 'Failed to unpack instruction data' */
export class TmInstructionUnpackErrorError extends ProgramError {
  readonly name: string = 'InstructionUnpackError';

  readonly code: number = 0x0; // 0

  constructor(program: Program, cause?: Error) {
    super('Failed to unpack instruction data', program, cause);
  }
}
codeToErrorMap.set(0x0, TmInstructionUnpackErrorError);
nameToErrorMap.set('InstructionUnpackError', TmInstructionUnpackErrorError);

/** InstructionPackError: 'Failed to pack instruction data' */
export class TmInstructionPackErrorError extends ProgramError {
  readonly name: string = 'InstructionPackError';

  readonly code: number = 0x1; // 1

  constructor(program: Program, cause?: Error) {
    super('Failed to pack instruction data', program, cause);
  }
}
codeToErrorMap.set(0x1, TmInstructionPackErrorError);
nameToErrorMap.set('InstructionPackError', TmInstructionPackErrorError);

/** NotRentExempt: 'Lamport balance below rent-exempt threshold' */
export class TmNotRentExemptError extends ProgramError {
  readonly name: string = 'NotRentExempt';

  readonly code: number = 0x2; // 2

  constructor(program: Program, cause?: Error) {
    super('Lamport balance below rent-exempt threshold', program, cause);
  }
}
codeToErrorMap.set(0x2, TmNotRentExemptError);
nameToErrorMap.set('NotRentExempt', TmNotRentExemptError);

/** AlreadyInitialized: 'Already initialized' */
export class TmAlreadyInitializedError extends ProgramError {
  readonly name: string = 'AlreadyInitialized';

  readonly code: number = 0x3; // 3

  constructor(program: Program, cause?: Error) {
    super('Already initialized', program, cause);
  }
}
codeToErrorMap.set(0x3, TmAlreadyInitializedError);
nameToErrorMap.set('AlreadyInitialized', TmAlreadyInitializedError);

/** Uninitialized: 'Uninitialized' */
export class TmUninitializedError extends ProgramError {
  readonly name: string = 'Uninitialized';

  readonly code: number = 0x4; // 4

  constructor(program: Program, cause?: Error) {
    super('Uninitialized', program, cause);
  }
}
codeToErrorMap.set(0x4, TmUninitializedError);
nameToErrorMap.set('Uninitialized', TmUninitializedError);

/** InvalidMetadataKey: ' Metadata's key must match seed of ['metadata', program id, mint] provided' */
export class TmInvalidMetadataKeyError extends ProgramError {
  readonly name: string = 'InvalidMetadataKey';

  readonly code: number = 0x5; // 5

  constructor(program: Program, cause?: Error) {
    super(
      " Metadata's key must match seed of ['metadata', program id, mint] provided",
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x5, TmInvalidMetadataKeyError);
nameToErrorMap.set('InvalidMetadataKey', TmInvalidMetadataKeyError);

/** InvalidEditionKey: 'Edition's key must match seed of ['metadata', program id, name, 'edition'] provided' */
export class TmInvalidEditionKeyError extends ProgramError {
  readonly name: string = 'InvalidEditionKey';

  readonly code: number = 0x6; // 6

  constructor(program: Program, cause?: Error) {
    super(
      "Edition's key must match seed of ['metadata', program id, name, 'edition'] provided",
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x6, TmInvalidEditionKeyError);
nameToErrorMap.set('InvalidEditionKey', TmInvalidEditionKeyError);

/** UpdateAuthorityIncorrect: 'Update Authority given does not match' */
export class TmUpdateAuthorityIncorrectError extends ProgramError {
  readonly name: string = 'UpdateAuthorityIncorrect';

  readonly code: number = 0x7; // 7

  constructor(program: Program, cause?: Error) {
    super('Update Authority given does not match', program, cause);
  }
}
codeToErrorMap.set(0x7, TmUpdateAuthorityIncorrectError);
nameToErrorMap.set('UpdateAuthorityIncorrect', TmUpdateAuthorityIncorrectError);

/** UpdateAuthorityIsNotSigner: 'Update Authority needs to be signer to update metadata' */
export class TmUpdateAuthorityIsNotSignerError extends ProgramError {
  readonly name: string = 'UpdateAuthorityIsNotSigner';

  readonly code: number = 0x8; // 8

  constructor(program: Program, cause?: Error) {
    super(
      'Update Authority needs to be signer to update metadata',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x8, TmUpdateAuthorityIsNotSignerError);
nameToErrorMap.set(
  'UpdateAuthorityIsNotSigner',
  TmUpdateAuthorityIsNotSignerError
);

/** NotMintAuthority: 'You must be the mint authority and signer on this transaction' */
export class TmNotMintAuthorityError extends ProgramError {
  readonly name: string = 'NotMintAuthority';

  readonly code: number = 0x9; // 9

  constructor(program: Program, cause?: Error) {
    super(
      'You must be the mint authority and signer on this transaction',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x9, TmNotMintAuthorityError);
nameToErrorMap.set('NotMintAuthority', TmNotMintAuthorityError);

/** InvalidMintAuthority: 'Mint authority provided does not match the authority on the mint' */
export class TmInvalidMintAuthorityError extends ProgramError {
  readonly name: string = 'InvalidMintAuthority';

  readonly code: number = 0xa; // 10

  constructor(program: Program, cause?: Error) {
    super(
      'Mint authority provided does not match the authority on the mint',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0xa, TmInvalidMintAuthorityError);
nameToErrorMap.set('InvalidMintAuthority', TmInvalidMintAuthorityError);

/** NameTooLong: 'Name too long' */
export class TmNameTooLongError extends ProgramError {
  readonly name: string = 'NameTooLong';

  readonly code: number = 0xb; // 11

  constructor(program: Program, cause?: Error) {
    super('Name too long', program, cause);
  }
}
codeToErrorMap.set(0xb, TmNameTooLongError);
nameToErrorMap.set('NameTooLong', TmNameTooLongError);

/** SymbolTooLong: 'Symbol too long' */
export class TmSymbolTooLongError extends ProgramError {
  readonly name: string = 'SymbolTooLong';

  readonly code: number = 0xc; // 12

  constructor(program: Program, cause?: Error) {
    super('Symbol too long', program, cause);
  }
}
codeToErrorMap.set(0xc, TmSymbolTooLongError);
nameToErrorMap.set('SymbolTooLong', TmSymbolTooLongError);

/** UriTooLong: 'URI too long' */
export class TmUriTooLongError extends ProgramError {
  readonly name: string = 'UriTooLong';

  readonly code: number = 0xd; // 13

  constructor(program: Program, cause?: Error) {
    super('URI too long', program, cause);
  }
}
codeToErrorMap.set(0xd, TmUriTooLongError);
nameToErrorMap.set('UriTooLong', TmUriTooLongError);

/** UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner: 'Update authority must be equivalent to the metadata's authority and also signer of this transaction' */
export class TmUpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError extends ProgramError {
  readonly name: string =
    'UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner';

  readonly code: number = 0xe; // 14

  constructor(program: Program, cause?: Error) {
    super(
      "Update authority must be equivalent to the metadata's authority and also signer of this transaction",
      program,
      cause
    );
  }
}
codeToErrorMap.set(
  0xe,
  TmUpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError
);
nameToErrorMap.set(
  'UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner',
  TmUpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError
);

/** MintMismatch: 'Mint given does not match mint on Metadata' */
export class TmMintMismatchError extends ProgramError {
  readonly name: string = 'MintMismatch';

  readonly code: number = 0xf; // 15

  constructor(program: Program, cause?: Error) {
    super('Mint given does not match mint on Metadata', program, cause);
  }
}
codeToErrorMap.set(0xf, TmMintMismatchError);
nameToErrorMap.set('MintMismatch', TmMintMismatchError);

/** EditionsMustHaveExactlyOneToken: 'Editions must have exactly one token' */
export class TmEditionsMustHaveExactlyOneTokenError extends ProgramError {
  readonly name: string = 'EditionsMustHaveExactlyOneToken';

  readonly code: number = 0x10; // 16

  constructor(program: Program, cause?: Error) {
    super('Editions must have exactly one token', program, cause);
  }
}
codeToErrorMap.set(0x10, TmEditionsMustHaveExactlyOneTokenError);
nameToErrorMap.set(
  'EditionsMustHaveExactlyOneToken',
  TmEditionsMustHaveExactlyOneTokenError
);

/** MaxEditionsMintedAlready: 'Maximum editions printed already' */
export class TmMaxEditionsMintedAlreadyError extends ProgramError {
  readonly name: string = 'MaxEditionsMintedAlready';

  readonly code: number = 0x11; // 17

  constructor(program: Program, cause?: Error) {
    super('Maximum editions printed already', program, cause);
  }
}
codeToErrorMap.set(0x11, TmMaxEditionsMintedAlreadyError);
nameToErrorMap.set('MaxEditionsMintedAlready', TmMaxEditionsMintedAlreadyError);

/** TokenMintToFailed: 'Token mint to failed' */
export class TmTokenMintToFailedError extends ProgramError {
  readonly name: string = 'TokenMintToFailed';

  readonly code: number = 0x12; // 18

  constructor(program: Program, cause?: Error) {
    super('Token mint to failed', program, cause);
  }
}
codeToErrorMap.set(0x12, TmTokenMintToFailedError);
nameToErrorMap.set('TokenMintToFailed', TmTokenMintToFailedError);

/** MasterRecordMismatch: 'The master edition record passed must match the master record on the edition given' */
export class TmMasterRecordMismatchError extends ProgramError {
  readonly name: string = 'MasterRecordMismatch';

  readonly code: number = 0x13; // 19

  constructor(program: Program, cause?: Error) {
    super(
      'The master edition record passed must match the master record on the edition given',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x13, TmMasterRecordMismatchError);
nameToErrorMap.set('MasterRecordMismatch', TmMasterRecordMismatchError);

/** DestinationMintMismatch: 'The destination account does not have the right mint' */
export class TmDestinationMintMismatchError extends ProgramError {
  readonly name: string = 'DestinationMintMismatch';

  readonly code: number = 0x14; // 20

  constructor(program: Program, cause?: Error) {
    super(
      'The destination account does not have the right mint',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x14, TmDestinationMintMismatchError);
nameToErrorMap.set('DestinationMintMismatch', TmDestinationMintMismatchError);

/** EditionAlreadyMinted: 'An edition can only mint one of its kind!' */
export class TmEditionAlreadyMintedError extends ProgramError {
  readonly name: string = 'EditionAlreadyMinted';

  readonly code: number = 0x15; // 21

  constructor(program: Program, cause?: Error) {
    super('An edition can only mint one of its kind!', program, cause);
  }
}
codeToErrorMap.set(0x15, TmEditionAlreadyMintedError);
nameToErrorMap.set('EditionAlreadyMinted', TmEditionAlreadyMintedError);

/** PrintingMintDecimalsShouldBeZero: 'Printing mint decimals should be zero' */
export class TmPrintingMintDecimalsShouldBeZeroError extends ProgramError {
  readonly name: string = 'PrintingMintDecimalsShouldBeZero';

  readonly code: number = 0x16; // 22

  constructor(program: Program, cause?: Error) {
    super('Printing mint decimals should be zero', program, cause);
  }
}
codeToErrorMap.set(0x16, TmPrintingMintDecimalsShouldBeZeroError);
nameToErrorMap.set(
  'PrintingMintDecimalsShouldBeZero',
  TmPrintingMintDecimalsShouldBeZeroError
);

/** OneTimePrintingAuthorizationMintDecimalsShouldBeZero: 'OneTimePrintingAuthorization mint decimals should be zero' */
export class TmOneTimePrintingAuthorizationMintDecimalsShouldBeZeroError extends ProgramError {
  readonly name: string =
    'OneTimePrintingAuthorizationMintDecimalsShouldBeZero';

  readonly code: number = 0x17; // 23

  constructor(program: Program, cause?: Error) {
    super(
      'OneTimePrintingAuthorization mint decimals should be zero',
      program,
      cause
    );
  }
}
codeToErrorMap.set(
  0x17,
  TmOneTimePrintingAuthorizationMintDecimalsShouldBeZeroError
);
nameToErrorMap.set(
  'OneTimePrintingAuthorizationMintDecimalsShouldBeZero',
  TmOneTimePrintingAuthorizationMintDecimalsShouldBeZeroError
);

/** EditionMintDecimalsShouldBeZero: 'EditionMintDecimalsShouldBeZero' */
export class TmEditionMintDecimalsShouldBeZeroError extends ProgramError {
  readonly name: string = 'EditionMintDecimalsShouldBeZero';

  readonly code: number = 0x18; // 24

  constructor(program: Program, cause?: Error) {
    super('EditionMintDecimalsShouldBeZero', program, cause);
  }
}
codeToErrorMap.set(0x18, TmEditionMintDecimalsShouldBeZeroError);
nameToErrorMap.set(
  'EditionMintDecimalsShouldBeZero',
  TmEditionMintDecimalsShouldBeZeroError
);

/** TokenBurnFailed: 'Token burn failed' */
export class TmTokenBurnFailedError extends ProgramError {
  readonly name: string = 'TokenBurnFailed';

  readonly code: number = 0x19; // 25

  constructor(program: Program, cause?: Error) {
    super('Token burn failed', program, cause);
  }
}
codeToErrorMap.set(0x19, TmTokenBurnFailedError);
nameToErrorMap.set('TokenBurnFailed', TmTokenBurnFailedError);

/** TokenAccountOneTimeAuthMintMismatch: 'The One Time authorization mint does not match that on the token account!' */
export class TmTokenAccountOneTimeAuthMintMismatchError extends ProgramError {
  readonly name: string = 'TokenAccountOneTimeAuthMintMismatch';

  readonly code: number = 0x1a; // 26

  constructor(program: Program, cause?: Error) {
    super(
      'The One Time authorization mint does not match that on the token account!',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x1a, TmTokenAccountOneTimeAuthMintMismatchError);
nameToErrorMap.set(
  'TokenAccountOneTimeAuthMintMismatch',
  TmTokenAccountOneTimeAuthMintMismatchError
);

/** DerivedKeyInvalid: 'Derived key invalid' */
export class TmDerivedKeyInvalidError extends ProgramError {
  readonly name: string = 'DerivedKeyInvalid';

  readonly code: number = 0x1b; // 27

  constructor(program: Program, cause?: Error) {
    super('Derived key invalid', program, cause);
  }
}
codeToErrorMap.set(0x1b, TmDerivedKeyInvalidError);
nameToErrorMap.set('DerivedKeyInvalid', TmDerivedKeyInvalidError);

/** PrintingMintMismatch: 'The Printing mint does not match that on the master edition!' */
export class TmPrintingMintMismatchError extends ProgramError {
  readonly name: string = 'PrintingMintMismatch';

  readonly code: number = 0x1c; // 28

  constructor(program: Program, cause?: Error) {
    super(
      'The Printing mint does not match that on the master edition!',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x1c, TmPrintingMintMismatchError);
nameToErrorMap.set('PrintingMintMismatch', TmPrintingMintMismatchError);

/** OneTimePrintingAuthMintMismatch: 'The One Time Printing Auth mint does not match that on the master edition!' */
export class TmOneTimePrintingAuthMintMismatchError extends ProgramError {
  readonly name: string = 'OneTimePrintingAuthMintMismatch';

  readonly code: number = 0x1d; // 29

  constructor(program: Program, cause?: Error) {
    super(
      'The One Time Printing Auth mint does not match that on the master edition!',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x1d, TmOneTimePrintingAuthMintMismatchError);
nameToErrorMap.set(
  'OneTimePrintingAuthMintMismatch',
  TmOneTimePrintingAuthMintMismatchError
);

/** TokenAccountMintMismatch: 'The mint of the token account does not match the Printing mint!' */
export class TmTokenAccountMintMismatchError extends ProgramError {
  readonly name: string = 'TokenAccountMintMismatch';

  readonly code: number = 0x1e; // 30

  constructor(program: Program, cause?: Error) {
    super(
      'The mint of the token account does not match the Printing mint!',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x1e, TmTokenAccountMintMismatchError);
nameToErrorMap.set('TokenAccountMintMismatch', TmTokenAccountMintMismatchError);

/** TokenAccountMintMismatchV2: 'The mint of the token account does not match the master metadata mint!' */
export class TmTokenAccountMintMismatchV2Error extends ProgramError {
  readonly name: string = 'TokenAccountMintMismatchV2';

  readonly code: number = 0x1f; // 31

  constructor(program: Program, cause?: Error) {
    super(
      'The mint of the token account does not match the master metadata mint!',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x1f, TmTokenAccountMintMismatchV2Error);
nameToErrorMap.set(
  'TokenAccountMintMismatchV2',
  TmTokenAccountMintMismatchV2Error
);

/** NotEnoughTokens: 'Not enough tokens to mint a limited edition' */
export class TmNotEnoughTokensError extends ProgramError {
  readonly name: string = 'NotEnoughTokens';

  readonly code: number = 0x20; // 32

  constructor(program: Program, cause?: Error) {
    super('Not enough tokens to mint a limited edition', program, cause);
  }
}
codeToErrorMap.set(0x20, TmNotEnoughTokensError);
nameToErrorMap.set('NotEnoughTokens', TmNotEnoughTokensError);

/** PrintingMintAuthorizationAccountMismatch: 'The mint on your authorization token holding account does not match your Printing mint!' */
export class TmPrintingMintAuthorizationAccountMismatchError extends ProgramError {
  readonly name: string = 'PrintingMintAuthorizationAccountMismatch';

  readonly code: number = 0x21; // 33

  constructor(program: Program, cause?: Error) {
    super(
      'The mint on your authorization token holding account does not match your Printing mint!',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x21, TmPrintingMintAuthorizationAccountMismatchError);
nameToErrorMap.set(
  'PrintingMintAuthorizationAccountMismatch',
  TmPrintingMintAuthorizationAccountMismatchError
);

/** AuthorizationTokenAccountOwnerMismatch: 'The authorization token account has a different owner than the update authority for the master edition!' */
export class TmAuthorizationTokenAccountOwnerMismatchError extends ProgramError {
  readonly name: string = 'AuthorizationTokenAccountOwnerMismatch';

  readonly code: number = 0x22; // 34

  constructor(program: Program, cause?: Error) {
    super(
      'The authorization token account has a different owner than the update authority for the master edition!',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x22, TmAuthorizationTokenAccountOwnerMismatchError);
nameToErrorMap.set(
  'AuthorizationTokenAccountOwnerMismatch',
  TmAuthorizationTokenAccountOwnerMismatchError
);

/** Disabled: 'This feature is currently disabled.' */
export class TmDisabledError extends ProgramError {
  readonly name: string = 'Disabled';

  readonly code: number = 0x23; // 35

  constructor(program: Program, cause?: Error) {
    super('This feature is currently disabled.', program, cause);
  }
}
codeToErrorMap.set(0x23, TmDisabledError);
nameToErrorMap.set('Disabled', TmDisabledError);

/** CreatorsTooLong: 'Creators list too long' */
export class TmCreatorsTooLongError extends ProgramError {
  readonly name: string = 'CreatorsTooLong';

  readonly code: number = 0x24; // 36

  constructor(program: Program, cause?: Error) {
    super('Creators list too long', program, cause);
  }
}
codeToErrorMap.set(0x24, TmCreatorsTooLongError);
nameToErrorMap.set('CreatorsTooLong', TmCreatorsTooLongError);

/** CreatorsMustBeAtleastOne: 'Creators must be at least one if set' */
export class TmCreatorsMustBeAtleastOneError extends ProgramError {
  readonly name: string = 'CreatorsMustBeAtleastOne';

  readonly code: number = 0x25; // 37

  constructor(program: Program, cause?: Error) {
    super('Creators must be at least one if set', program, cause);
  }
}
codeToErrorMap.set(0x25, TmCreatorsMustBeAtleastOneError);
nameToErrorMap.set('CreatorsMustBeAtleastOne', TmCreatorsMustBeAtleastOneError);

/** MustBeOneOfCreators: 'If using a creators array, you must be one of the creators listed' */
export class TmMustBeOneOfCreatorsError extends ProgramError {
  readonly name: string = 'MustBeOneOfCreators';

  readonly code: number = 0x26; // 38

  constructor(program: Program, cause?: Error) {
    super(
      'If using a creators array, you must be one of the creators listed',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x26, TmMustBeOneOfCreatorsError);
nameToErrorMap.set('MustBeOneOfCreators', TmMustBeOneOfCreatorsError);

/** NoCreatorsPresentOnMetadata: 'This metadata does not have creators' */
export class TmNoCreatorsPresentOnMetadataError extends ProgramError {
  readonly name: string = 'NoCreatorsPresentOnMetadata';

  readonly code: number = 0x27; // 39

  constructor(program: Program, cause?: Error) {
    super('This metadata does not have creators', program, cause);
  }
}
codeToErrorMap.set(0x27, TmNoCreatorsPresentOnMetadataError);
nameToErrorMap.set(
  'NoCreatorsPresentOnMetadata',
  TmNoCreatorsPresentOnMetadataError
);

/** CreatorNotFound: 'This creator address was not found' */
export class TmCreatorNotFoundError extends ProgramError {
  readonly name: string = 'CreatorNotFound';

  readonly code: number = 0x28; // 40

  constructor(program: Program, cause?: Error) {
    super('This creator address was not found', program, cause);
  }
}
codeToErrorMap.set(0x28, TmCreatorNotFoundError);
nameToErrorMap.set('CreatorNotFound', TmCreatorNotFoundError);

/** InvalidBasisPoints: 'Basis points cannot be more than 10000' */
export class TmInvalidBasisPointsError extends ProgramError {
  readonly name: string = 'InvalidBasisPoints';

  readonly code: number = 0x29; // 41

  constructor(program: Program, cause?: Error) {
    super('Basis points cannot be more than 10000', program, cause);
  }
}
codeToErrorMap.set(0x29, TmInvalidBasisPointsError);
nameToErrorMap.set('InvalidBasisPoints', TmInvalidBasisPointsError);

/** PrimarySaleCanOnlyBeFlippedToTrue: 'Primary sale can only be flipped to true and is immutable' */
export class TmPrimarySaleCanOnlyBeFlippedToTrueError extends ProgramError {
  readonly name: string = 'PrimarySaleCanOnlyBeFlippedToTrue';

  readonly code: number = 0x2a; // 42

  constructor(program: Program, cause?: Error) {
    super(
      'Primary sale can only be flipped to true and is immutable',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x2a, TmPrimarySaleCanOnlyBeFlippedToTrueError);
nameToErrorMap.set(
  'PrimarySaleCanOnlyBeFlippedToTrue',
  TmPrimarySaleCanOnlyBeFlippedToTrueError
);

/** OwnerMismatch: 'Owner does not match that on the account given' */
export class TmOwnerMismatchError extends ProgramError {
  readonly name: string = 'OwnerMismatch';

  readonly code: number = 0x2b; // 43

  constructor(program: Program, cause?: Error) {
    super('Owner does not match that on the account given', program, cause);
  }
}
codeToErrorMap.set(0x2b, TmOwnerMismatchError);
nameToErrorMap.set('OwnerMismatch', TmOwnerMismatchError);

/** NoBalanceInAccountForAuthorization: 'This account has no tokens to be used for authorization' */
export class TmNoBalanceInAccountForAuthorizationError extends ProgramError {
  readonly name: string = 'NoBalanceInAccountForAuthorization';

  readonly code: number = 0x2c; // 44

  constructor(program: Program, cause?: Error) {
    super(
      'This account has no tokens to be used for authorization',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x2c, TmNoBalanceInAccountForAuthorizationError);
nameToErrorMap.set(
  'NoBalanceInAccountForAuthorization',
  TmNoBalanceInAccountForAuthorizationError
);

/** ShareTotalMustBe100: 'Share total must equal 100 for creator array' */
export class TmShareTotalMustBe100Error extends ProgramError {
  readonly name: string = 'ShareTotalMustBe100';

  readonly code: number = 0x2d; // 45

  constructor(program: Program, cause?: Error) {
    super('Share total must equal 100 for creator array', program, cause);
  }
}
codeToErrorMap.set(0x2d, TmShareTotalMustBe100Error);
nameToErrorMap.set('ShareTotalMustBe100', TmShareTotalMustBe100Error);

/** ReservationExists: 'This reservation list already exists!' */
export class TmReservationExistsError extends ProgramError {
  readonly name: string = 'ReservationExists';

  readonly code: number = 0x2e; // 46

  constructor(program: Program, cause?: Error) {
    super('This reservation list already exists!', program, cause);
  }
}
codeToErrorMap.set(0x2e, TmReservationExistsError);
nameToErrorMap.set('ReservationExists', TmReservationExistsError);

/** ReservationDoesNotExist: 'This reservation list does not exist!' */
export class TmReservationDoesNotExistError extends ProgramError {
  readonly name: string = 'ReservationDoesNotExist';

  readonly code: number = 0x2f; // 47

  constructor(program: Program, cause?: Error) {
    super('This reservation list does not exist!', program, cause);
  }
}
codeToErrorMap.set(0x2f, TmReservationDoesNotExistError);
nameToErrorMap.set('ReservationDoesNotExist', TmReservationDoesNotExistError);

/** ReservationNotSet: 'This reservation list exists but was never set with reservations' */
export class TmReservationNotSetError extends ProgramError {
  readonly name: string = 'ReservationNotSet';

  readonly code: number = 0x30; // 48

  constructor(program: Program, cause?: Error) {
    super(
      'This reservation list exists but was never set with reservations',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x30, TmReservationNotSetError);
nameToErrorMap.set('ReservationNotSet', TmReservationNotSetError);

/** ReservationAlreadyMade: 'This reservation list has already been set!' */
export class TmReservationAlreadyMadeError extends ProgramError {
  readonly name: string = 'ReservationAlreadyMade';

  readonly code: number = 0x31; // 49

  constructor(program: Program, cause?: Error) {
    super('This reservation list has already been set!', program, cause);
  }
}
codeToErrorMap.set(0x31, TmReservationAlreadyMadeError);
nameToErrorMap.set('ReservationAlreadyMade', TmReservationAlreadyMadeError);

/** BeyondMaxAddressSize: 'Provided more addresses than max allowed in single reservation' */
export class TmBeyondMaxAddressSizeError extends ProgramError {
  readonly name: string = 'BeyondMaxAddressSize';

  readonly code: number = 0x32; // 50

  constructor(program: Program, cause?: Error) {
    super(
      'Provided more addresses than max allowed in single reservation',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x32, TmBeyondMaxAddressSizeError);
nameToErrorMap.set('BeyondMaxAddressSize', TmBeyondMaxAddressSizeError);

/** NumericalOverflowError: 'NumericalOverflowError' */
export class TmNumericalOverflowErrorError extends ProgramError {
  readonly name: string = 'NumericalOverflowError';

  readonly code: number = 0x33; // 51

  constructor(program: Program, cause?: Error) {
    super('NumericalOverflowError', program, cause);
  }
}
codeToErrorMap.set(0x33, TmNumericalOverflowErrorError);
nameToErrorMap.set('NumericalOverflowError', TmNumericalOverflowErrorError);

/** ReservationBreachesMaximumSupply: 'This reservation would go beyond the maximum supply of the master edition!' */
export class TmReservationBreachesMaximumSupplyError extends ProgramError {
  readonly name: string = 'ReservationBreachesMaximumSupply';

  readonly code: number = 0x34; // 52

  constructor(program: Program, cause?: Error) {
    super(
      'This reservation would go beyond the maximum supply of the master edition!',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x34, TmReservationBreachesMaximumSupplyError);
nameToErrorMap.set(
  'ReservationBreachesMaximumSupply',
  TmReservationBreachesMaximumSupplyError
);

/** AddressNotInReservation: 'Address not in reservation!' */
export class TmAddressNotInReservationError extends ProgramError {
  readonly name: string = 'AddressNotInReservation';

  readonly code: number = 0x35; // 53

  constructor(program: Program, cause?: Error) {
    super('Address not in reservation!', program, cause);
  }
}
codeToErrorMap.set(0x35, TmAddressNotInReservationError);
nameToErrorMap.set('AddressNotInReservation', TmAddressNotInReservationError);

/** CannotVerifyAnotherCreator: 'You cannot unilaterally verify another creator, they must sign' */
export class TmCannotVerifyAnotherCreatorError extends ProgramError {
  readonly name: string = 'CannotVerifyAnotherCreator';

  readonly code: number = 0x36; // 54

  constructor(program: Program, cause?: Error) {
    super(
      'You cannot unilaterally verify another creator, they must sign',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x36, TmCannotVerifyAnotherCreatorError);
nameToErrorMap.set(
  'CannotVerifyAnotherCreator',
  TmCannotVerifyAnotherCreatorError
);

/** CannotUnverifyAnotherCreator: 'You cannot unilaterally unverify another creator' */
export class TmCannotUnverifyAnotherCreatorError extends ProgramError {
  readonly name: string = 'CannotUnverifyAnotherCreator';

  readonly code: number = 0x37; // 55

  constructor(program: Program, cause?: Error) {
    super('You cannot unilaterally unverify another creator', program, cause);
  }
}
codeToErrorMap.set(0x37, TmCannotUnverifyAnotherCreatorError);
nameToErrorMap.set(
  'CannotUnverifyAnotherCreator',
  TmCannotUnverifyAnotherCreatorError
);

/** SpotMismatch: 'In initial reservation setting, spots remaining should equal total spots' */
export class TmSpotMismatchError extends ProgramError {
  readonly name: string = 'SpotMismatch';

  readonly code: number = 0x38; // 56

  constructor(program: Program, cause?: Error) {
    super(
      'In initial reservation setting, spots remaining should equal total spots',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x38, TmSpotMismatchError);
nameToErrorMap.set('SpotMismatch', TmSpotMismatchError);

/** IncorrectOwner: 'Incorrect account owner' */
export class TmIncorrectOwnerError extends ProgramError {
  readonly name: string = 'IncorrectOwner';

  readonly code: number = 0x39; // 57

  constructor(program: Program, cause?: Error) {
    super('Incorrect account owner', program, cause);
  }
}
codeToErrorMap.set(0x39, TmIncorrectOwnerError);
nameToErrorMap.set('IncorrectOwner', TmIncorrectOwnerError);

/** PrintingWouldBreachMaximumSupply: 'printing these tokens would breach the maximum supply limit of the master edition' */
export class TmPrintingWouldBreachMaximumSupplyError extends ProgramError {
  readonly name: string = 'PrintingWouldBreachMaximumSupply';

  readonly code: number = 0x3a; // 58

  constructor(program: Program, cause?: Error) {
    super(
      'printing these tokens would breach the maximum supply limit of the master edition',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x3a, TmPrintingWouldBreachMaximumSupplyError);
nameToErrorMap.set(
  'PrintingWouldBreachMaximumSupply',
  TmPrintingWouldBreachMaximumSupplyError
);

/** DataIsImmutable: 'Data is immutable' */
export class TmDataIsImmutableError extends ProgramError {
  readonly name: string = 'DataIsImmutable';

  readonly code: number = 0x3b; // 59

  constructor(program: Program, cause?: Error) {
    super('Data is immutable', program, cause);
  }
}
codeToErrorMap.set(0x3b, TmDataIsImmutableError);
nameToErrorMap.set('DataIsImmutable', TmDataIsImmutableError);

/** DuplicateCreatorAddress: 'No duplicate creator addresses' */
export class TmDuplicateCreatorAddressError extends ProgramError {
  readonly name: string = 'DuplicateCreatorAddress';

  readonly code: number = 0x3c; // 60

  constructor(program: Program, cause?: Error) {
    super('No duplicate creator addresses', program, cause);
  }
}
codeToErrorMap.set(0x3c, TmDuplicateCreatorAddressError);
nameToErrorMap.set('DuplicateCreatorAddress', TmDuplicateCreatorAddressError);

/** ReservationSpotsRemainingShouldMatchTotalSpotsAtStart: 'Reservation spots remaining should match total spots when first being created' */
export class TmReservationSpotsRemainingShouldMatchTotalSpotsAtStartError extends ProgramError {
  readonly name: string =
    'ReservationSpotsRemainingShouldMatchTotalSpotsAtStart';

  readonly code: number = 0x3d; // 61

  constructor(program: Program, cause?: Error) {
    super(
      'Reservation spots remaining should match total spots when first being created',
      program,
      cause
    );
  }
}
codeToErrorMap.set(
  0x3d,
  TmReservationSpotsRemainingShouldMatchTotalSpotsAtStartError
);
nameToErrorMap.set(
  'ReservationSpotsRemainingShouldMatchTotalSpotsAtStart',
  TmReservationSpotsRemainingShouldMatchTotalSpotsAtStartError
);

/** InvalidTokenProgram: 'Invalid token program' */
export class TmInvalidTokenProgramError extends ProgramError {
  readonly name: string = 'InvalidTokenProgram';

  readonly code: number = 0x3e; // 62

  constructor(program: Program, cause?: Error) {
    super('Invalid token program', program, cause);
  }
}
codeToErrorMap.set(0x3e, TmInvalidTokenProgramError);
nameToErrorMap.set('InvalidTokenProgram', TmInvalidTokenProgramError);

/** DataTypeMismatch: 'Data type mismatch' */
export class TmDataTypeMismatchError extends ProgramError {
  readonly name: string = 'DataTypeMismatch';

  readonly code: number = 0x3f; // 63

  constructor(program: Program, cause?: Error) {
    super('Data type mismatch', program, cause);
  }
}
codeToErrorMap.set(0x3f, TmDataTypeMismatchError);
nameToErrorMap.set('DataTypeMismatch', TmDataTypeMismatchError);

/** BeyondAlottedAddressSize: 'Beyond alotted address size in reservation!' */
export class TmBeyondAlottedAddressSizeError extends ProgramError {
  readonly name: string = 'BeyondAlottedAddressSize';

  readonly code: number = 0x40; // 64

  constructor(program: Program, cause?: Error) {
    super('Beyond alotted address size in reservation!', program, cause);
  }
}
codeToErrorMap.set(0x40, TmBeyondAlottedAddressSizeError);
nameToErrorMap.set('BeyondAlottedAddressSize', TmBeyondAlottedAddressSizeError);

/** ReservationNotComplete: 'The reservation has only been partially alotted' */
export class TmReservationNotCompleteError extends ProgramError {
  readonly name: string = 'ReservationNotComplete';

  readonly code: number = 0x41; // 65

  constructor(program: Program, cause?: Error) {
    super('The reservation has only been partially alotted', program, cause);
  }
}
codeToErrorMap.set(0x41, TmReservationNotCompleteError);
nameToErrorMap.set('ReservationNotComplete', TmReservationNotCompleteError);

/** TriedToReplaceAnExistingReservation: 'You cannot splice over an existing reservation!' */
export class TmTriedToReplaceAnExistingReservationError extends ProgramError {
  readonly name: string = 'TriedToReplaceAnExistingReservation';

  readonly code: number = 0x42; // 66

  constructor(program: Program, cause?: Error) {
    super('You cannot splice over an existing reservation!', program, cause);
  }
}
codeToErrorMap.set(0x42, TmTriedToReplaceAnExistingReservationError);
nameToErrorMap.set(
  'TriedToReplaceAnExistingReservation',
  TmTriedToReplaceAnExistingReservationError
);

/** InvalidOperation: 'Invalid operation' */
export class TmInvalidOperationError extends ProgramError {
  readonly name: string = 'InvalidOperation';

  readonly code: number = 0x43; // 67

  constructor(program: Program, cause?: Error) {
    super('Invalid operation', program, cause);
  }
}
codeToErrorMap.set(0x43, TmInvalidOperationError);
nameToErrorMap.set('InvalidOperation', TmInvalidOperationError);

/** InvalidOwner: 'Invalid Owner' */
export class TmInvalidOwnerError extends ProgramError {
  readonly name: string = 'InvalidOwner';

  readonly code: number = 0x44; // 68

  constructor(program: Program, cause?: Error) {
    super('Invalid Owner', program, cause);
  }
}
codeToErrorMap.set(0x44, TmInvalidOwnerError);
nameToErrorMap.set('InvalidOwner', TmInvalidOwnerError);

/** PrintingMintSupplyMustBeZeroForConversion: 'Printing mint supply must be zero for conversion' */
export class TmPrintingMintSupplyMustBeZeroForConversionError extends ProgramError {
  readonly name: string = 'PrintingMintSupplyMustBeZeroForConversion';

  readonly code: number = 0x45; // 69

  constructor(program: Program, cause?: Error) {
    super('Printing mint supply must be zero for conversion', program, cause);
  }
}
codeToErrorMap.set(0x45, TmPrintingMintSupplyMustBeZeroForConversionError);
nameToErrorMap.set(
  'PrintingMintSupplyMustBeZeroForConversion',
  TmPrintingMintSupplyMustBeZeroForConversionError
);

/** OneTimeAuthMintSupplyMustBeZeroForConversion: 'One Time Auth mint supply must be zero for conversion' */
export class TmOneTimeAuthMintSupplyMustBeZeroForConversionError extends ProgramError {
  readonly name: string = 'OneTimeAuthMintSupplyMustBeZeroForConversion';

  readonly code: number = 0x46; // 70

  constructor(program: Program, cause?: Error) {
    super(
      'One Time Auth mint supply must be zero for conversion',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x46, TmOneTimeAuthMintSupplyMustBeZeroForConversionError);
nameToErrorMap.set(
  'OneTimeAuthMintSupplyMustBeZeroForConversion',
  TmOneTimeAuthMintSupplyMustBeZeroForConversionError
);

/** InvalidEditionIndex: 'You tried to insert one edition too many into an edition mark pda' */
export class TmInvalidEditionIndexError extends ProgramError {
  readonly name: string = 'InvalidEditionIndex';

  readonly code: number = 0x47; // 71

  constructor(program: Program, cause?: Error) {
    super(
      'You tried to insert one edition too many into an edition mark pda',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x47, TmInvalidEditionIndexError);
nameToErrorMap.set('InvalidEditionIndex', TmInvalidEditionIndexError);

/** ReservationArrayShouldBeSizeOne: 'In the legacy system the reservation needs to be of size one for cpu limit reasons' */
export class TmReservationArrayShouldBeSizeOneError extends ProgramError {
  readonly name: string = 'ReservationArrayShouldBeSizeOne';

  readonly code: number = 0x48; // 72

  constructor(program: Program, cause?: Error) {
    super(
      'In the legacy system the reservation needs to be of size one for cpu limit reasons',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x48, TmReservationArrayShouldBeSizeOneError);
nameToErrorMap.set(
  'ReservationArrayShouldBeSizeOne',
  TmReservationArrayShouldBeSizeOneError
);

/** IsMutableCanOnlyBeFlippedToFalse: 'Is Mutable can only be flipped to false' */
export class TmIsMutableCanOnlyBeFlippedToFalseError extends ProgramError {
  readonly name: string = 'IsMutableCanOnlyBeFlippedToFalse';

  readonly code: number = 0x49; // 73

  constructor(program: Program, cause?: Error) {
    super('Is Mutable can only be flipped to false', program, cause);
  }
}
codeToErrorMap.set(0x49, TmIsMutableCanOnlyBeFlippedToFalseError);
nameToErrorMap.set(
  'IsMutableCanOnlyBeFlippedToFalse',
  TmIsMutableCanOnlyBeFlippedToFalseError
);

/** CollectionCannotBeVerifiedInThisInstruction: 'Cannont Verify Collection in this Instruction' */
export class TmCollectionCannotBeVerifiedInThisInstructionError extends ProgramError {
  readonly name: string = 'CollectionCannotBeVerifiedInThisInstruction';

  readonly code: number = 0x4a; // 74

  constructor(program: Program, cause?: Error) {
    super('Cannont Verify Collection in this Instruction', program, cause);
  }
}
codeToErrorMap.set(0x4a, TmCollectionCannotBeVerifiedInThisInstructionError);
nameToErrorMap.set(
  'CollectionCannotBeVerifiedInThisInstruction',
  TmCollectionCannotBeVerifiedInThisInstructionError
);

/** Removed: 'This instruction was deprecated in a previous release and is now removed' */
export class TmRemovedError extends ProgramError {
  readonly name: string = 'Removed';

  readonly code: number = 0x4b; // 75

  constructor(program: Program, cause?: Error) {
    super(
      'This instruction was deprecated in a previous release and is now removed',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x4b, TmRemovedError);
nameToErrorMap.set('Removed', TmRemovedError);

/** MustBeBurned: 'This token use method is burn and there are no remaining uses, it must be burned' */
export class TmMustBeBurnedError extends ProgramError {
  readonly name: string = 'MustBeBurned';

  readonly code: number = 0x4c; // 76

  constructor(program: Program, cause?: Error) {
    super(
      'This token use method is burn and there are no remaining uses, it must be burned',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x4c, TmMustBeBurnedError);
nameToErrorMap.set('MustBeBurned', TmMustBeBurnedError);

/** InvalidUseMethod: 'This use method is invalid' */
export class TmInvalidUseMethodError extends ProgramError {
  readonly name: string = 'InvalidUseMethod';

  readonly code: number = 0x4d; // 77

  constructor(program: Program, cause?: Error) {
    super('This use method is invalid', program, cause);
  }
}
codeToErrorMap.set(0x4d, TmInvalidUseMethodError);
nameToErrorMap.set('InvalidUseMethod', TmInvalidUseMethodError);

/** CannotChangeUseMethodAfterFirstUse: 'Cannot Change Use Method after the first use' */
export class TmCannotChangeUseMethodAfterFirstUseError extends ProgramError {
  readonly name: string = 'CannotChangeUseMethodAfterFirstUse';

  readonly code: number = 0x4e; // 78

  constructor(program: Program, cause?: Error) {
    super('Cannot Change Use Method after the first use', program, cause);
  }
}
codeToErrorMap.set(0x4e, TmCannotChangeUseMethodAfterFirstUseError);
nameToErrorMap.set(
  'CannotChangeUseMethodAfterFirstUse',
  TmCannotChangeUseMethodAfterFirstUseError
);

/** CannotChangeUsesAfterFirstUse: 'Cannot Change Remaining or Available uses after the first use' */
export class TmCannotChangeUsesAfterFirstUseError extends ProgramError {
  readonly name: string = 'CannotChangeUsesAfterFirstUse';

  readonly code: number = 0x4f; // 79

  constructor(program: Program, cause?: Error) {
    super(
      'Cannot Change Remaining or Available uses after the first use',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x4f, TmCannotChangeUsesAfterFirstUseError);
nameToErrorMap.set(
  'CannotChangeUsesAfterFirstUse',
  TmCannotChangeUsesAfterFirstUseError
);

/** CollectionNotFound: 'Collection Not Found on Metadata' */
export class TmCollectionNotFoundError extends ProgramError {
  readonly name: string = 'CollectionNotFound';

  readonly code: number = 0x50; // 80

  constructor(program: Program, cause?: Error) {
    super('Collection Not Found on Metadata', program, cause);
  }
}
codeToErrorMap.set(0x50, TmCollectionNotFoundError);
nameToErrorMap.set('CollectionNotFound', TmCollectionNotFoundError);

/** InvalidCollectionUpdateAuthority: 'Collection Update Authority is invalid' */
export class TmInvalidCollectionUpdateAuthorityError extends ProgramError {
  readonly name: string = 'InvalidCollectionUpdateAuthority';

  readonly code: number = 0x51; // 81

  constructor(program: Program, cause?: Error) {
    super('Collection Update Authority is invalid', program, cause);
  }
}
codeToErrorMap.set(0x51, TmInvalidCollectionUpdateAuthorityError);
nameToErrorMap.set(
  'InvalidCollectionUpdateAuthority',
  TmInvalidCollectionUpdateAuthorityError
);

/** CollectionMustBeAUniqueMasterEdition: 'Collection Must Be a Unique Master Edition v2' */
export class TmCollectionMustBeAUniqueMasterEditionError extends ProgramError {
  readonly name: string = 'CollectionMustBeAUniqueMasterEdition';

  readonly code: number = 0x52; // 82

  constructor(program: Program, cause?: Error) {
    super('Collection Must Be a Unique Master Edition v2', program, cause);
  }
}
codeToErrorMap.set(0x52, TmCollectionMustBeAUniqueMasterEditionError);
nameToErrorMap.set(
  'CollectionMustBeAUniqueMasterEdition',
  TmCollectionMustBeAUniqueMasterEditionError
);

/** UseAuthorityRecordAlreadyExists: 'The Use Authority Record Already Exists, to modify it Revoke, then Approve' */
export class TmUseAuthorityRecordAlreadyExistsError extends ProgramError {
  readonly name: string = 'UseAuthorityRecordAlreadyExists';

  readonly code: number = 0x53; // 83

  constructor(program: Program, cause?: Error) {
    super(
      'The Use Authority Record Already Exists, to modify it Revoke, then Approve',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x53, TmUseAuthorityRecordAlreadyExistsError);
nameToErrorMap.set(
  'UseAuthorityRecordAlreadyExists',
  TmUseAuthorityRecordAlreadyExistsError
);

/** UseAuthorityRecordAlreadyRevoked: 'The Use Authority Record is empty or already revoked' */
export class TmUseAuthorityRecordAlreadyRevokedError extends ProgramError {
  readonly name: string = 'UseAuthorityRecordAlreadyRevoked';

  readonly code: number = 0x54; // 84

  constructor(program: Program, cause?: Error) {
    super(
      'The Use Authority Record is empty or already revoked',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x54, TmUseAuthorityRecordAlreadyRevokedError);
nameToErrorMap.set(
  'UseAuthorityRecordAlreadyRevoked',
  TmUseAuthorityRecordAlreadyRevokedError
);

/** Unusable: 'This token has no uses' */
export class TmUnusableError extends ProgramError {
  readonly name: string = 'Unusable';

  readonly code: number = 0x55; // 85

  constructor(program: Program, cause?: Error) {
    super('This token has no uses', program, cause);
  }
}
codeToErrorMap.set(0x55, TmUnusableError);
nameToErrorMap.set('Unusable', TmUnusableError);

/** NotEnoughUses: 'There are not enough Uses left on this token.' */
export class TmNotEnoughUsesError extends ProgramError {
  readonly name: string = 'NotEnoughUses';

  readonly code: number = 0x56; // 86

  constructor(program: Program, cause?: Error) {
    super('There are not enough Uses left on this token.', program, cause);
  }
}
codeToErrorMap.set(0x56, TmNotEnoughUsesError);
nameToErrorMap.set('NotEnoughUses', TmNotEnoughUsesError);

/** CollectionAuthorityRecordAlreadyExists: 'This Collection Authority Record Already Exists.' */
export class TmCollectionAuthorityRecordAlreadyExistsError extends ProgramError {
  readonly name: string = 'CollectionAuthorityRecordAlreadyExists';

  readonly code: number = 0x57; // 87

  constructor(program: Program, cause?: Error) {
    super('This Collection Authority Record Already Exists.', program, cause);
  }
}
codeToErrorMap.set(0x57, TmCollectionAuthorityRecordAlreadyExistsError);
nameToErrorMap.set(
  'CollectionAuthorityRecordAlreadyExists',
  TmCollectionAuthorityRecordAlreadyExistsError
);

/** CollectionAuthorityDoesNotExist: 'This Collection Authority Record Does Not Exist.' */
export class TmCollectionAuthorityDoesNotExistError extends ProgramError {
  readonly name: string = 'CollectionAuthorityDoesNotExist';

  readonly code: number = 0x58; // 88

  constructor(program: Program, cause?: Error) {
    super('This Collection Authority Record Does Not Exist.', program, cause);
  }
}
codeToErrorMap.set(0x58, TmCollectionAuthorityDoesNotExistError);
nameToErrorMap.set(
  'CollectionAuthorityDoesNotExist',
  TmCollectionAuthorityDoesNotExistError
);

/** InvalidUseAuthorityRecord: 'This Use Authority Record is invalid.' */
export class TmInvalidUseAuthorityRecordError extends ProgramError {
  readonly name: string = 'InvalidUseAuthorityRecord';

  readonly code: number = 0x59; // 89

  constructor(program: Program, cause?: Error) {
    super('This Use Authority Record is invalid.', program, cause);
  }
}
codeToErrorMap.set(0x59, TmInvalidUseAuthorityRecordError);
nameToErrorMap.set(
  'InvalidUseAuthorityRecord',
  TmInvalidUseAuthorityRecordError
);

/** InvalidCollectionAuthorityRecord: 'This Collection Authority Record is invalid.' */
export class TmInvalidCollectionAuthorityRecordError extends ProgramError {
  readonly name: string = 'InvalidCollectionAuthorityRecord';

  readonly code: number = 0x5a; // 90

  constructor(program: Program, cause?: Error) {
    super('This Collection Authority Record is invalid.', program, cause);
  }
}
codeToErrorMap.set(0x5a, TmInvalidCollectionAuthorityRecordError);
nameToErrorMap.set(
  'InvalidCollectionAuthorityRecord',
  TmInvalidCollectionAuthorityRecordError
);

/** InvalidFreezeAuthority: 'Metadata does not match the freeze authority on the mint' */
export class TmInvalidFreezeAuthorityError extends ProgramError {
  readonly name: string = 'InvalidFreezeAuthority';

  readonly code: number = 0x5b; // 91

  constructor(program: Program, cause?: Error) {
    super(
      'Metadata does not match the freeze authority on the mint',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x5b, TmInvalidFreezeAuthorityError);
nameToErrorMap.set('InvalidFreezeAuthority', TmInvalidFreezeAuthorityError);

/** InvalidDelegate: 'All tokens in this account have not been delegated to this user.' */
export class TmInvalidDelegateError extends ProgramError {
  readonly name: string = 'InvalidDelegate';

  readonly code: number = 0x5c; // 92

  constructor(program: Program, cause?: Error) {
    super(
      'All tokens in this account have not been delegated to this user.',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x5c, TmInvalidDelegateError);
nameToErrorMap.set('InvalidDelegate', TmInvalidDelegateError);

/** CannotAdjustVerifiedCreator: 'Creator can not be adjusted once they are verified.' */
export class TmCannotAdjustVerifiedCreatorError extends ProgramError {
  readonly name: string = 'CannotAdjustVerifiedCreator';

  readonly code: number = 0x5d; // 93

  constructor(program: Program, cause?: Error) {
    super(
      'Creator can not be adjusted once they are verified.',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x5d, TmCannotAdjustVerifiedCreatorError);
nameToErrorMap.set(
  'CannotAdjustVerifiedCreator',
  TmCannotAdjustVerifiedCreatorError
);

/** CannotRemoveVerifiedCreator: 'Verified creators cannot be removed.' */
export class TmCannotRemoveVerifiedCreatorError extends ProgramError {
  readonly name: string = 'CannotRemoveVerifiedCreator';

  readonly code: number = 0x5e; // 94

  constructor(program: Program, cause?: Error) {
    super('Verified creators cannot be removed.', program, cause);
  }
}
codeToErrorMap.set(0x5e, TmCannotRemoveVerifiedCreatorError);
nameToErrorMap.set(
  'CannotRemoveVerifiedCreator',
  TmCannotRemoveVerifiedCreatorError
);

/** CannotWipeVerifiedCreators: 'Can not wipe verified creators.' */
export class TmCannotWipeVerifiedCreatorsError extends ProgramError {
  readonly name: string = 'CannotWipeVerifiedCreators';

  readonly code: number = 0x5f; // 95

  constructor(program: Program, cause?: Error) {
    super('Can not wipe verified creators.', program, cause);
  }
}
codeToErrorMap.set(0x5f, TmCannotWipeVerifiedCreatorsError);
nameToErrorMap.set(
  'CannotWipeVerifiedCreators',
  TmCannotWipeVerifiedCreatorsError
);

/** NotAllowedToChangeSellerFeeBasisPoints: 'Not allowed to change seller fee basis points.' */
export class TmNotAllowedToChangeSellerFeeBasisPointsError extends ProgramError {
  readonly name: string = 'NotAllowedToChangeSellerFeeBasisPoints';

  readonly code: number = 0x60; // 96

  constructor(program: Program, cause?: Error) {
    super('Not allowed to change seller fee basis points.', program, cause);
  }
}
codeToErrorMap.set(0x60, TmNotAllowedToChangeSellerFeeBasisPointsError);
nameToErrorMap.set(
  'NotAllowedToChangeSellerFeeBasisPoints',
  TmNotAllowedToChangeSellerFeeBasisPointsError
);

/** EditionOverrideCannotBeZero: 'Edition override cannot be zero' */
export class TmEditionOverrideCannotBeZeroError extends ProgramError {
  readonly name: string = 'EditionOverrideCannotBeZero';

  readonly code: number = 0x61; // 97

  constructor(program: Program, cause?: Error) {
    super('Edition override cannot be zero', program, cause);
  }
}
codeToErrorMap.set(0x61, TmEditionOverrideCannotBeZeroError);
nameToErrorMap.set(
  'EditionOverrideCannotBeZero',
  TmEditionOverrideCannotBeZeroError
);

/** InvalidUser: 'Invalid User' */
export class TmInvalidUserError extends ProgramError {
  readonly name: string = 'InvalidUser';

  readonly code: number = 0x62; // 98

  constructor(program: Program, cause?: Error) {
    super('Invalid User', program, cause);
  }
}
codeToErrorMap.set(0x62, TmInvalidUserError);
nameToErrorMap.set('InvalidUser', TmInvalidUserError);

/** RevokeCollectionAuthoritySignerIncorrect: 'Revoke Collection Authority signer is incorrect' */
export class TmRevokeCollectionAuthoritySignerIncorrectError extends ProgramError {
  readonly name: string = 'RevokeCollectionAuthoritySignerIncorrect';

  readonly code: number = 0x63; // 99

  constructor(program: Program, cause?: Error) {
    super('Revoke Collection Authority signer is incorrect', program, cause);
  }
}
codeToErrorMap.set(0x63, TmRevokeCollectionAuthoritySignerIncorrectError);
nameToErrorMap.set(
  'RevokeCollectionAuthoritySignerIncorrect',
  TmRevokeCollectionAuthoritySignerIncorrectError
);

/** TokenCloseFailed: 'Token close failed' */
export class TmTokenCloseFailedError extends ProgramError {
  readonly name: string = 'TokenCloseFailed';

  readonly code: number = 0x64; // 100

  constructor(program: Program, cause?: Error) {
    super('Token close failed', program, cause);
  }
}
codeToErrorMap.set(0x64, TmTokenCloseFailedError);
nameToErrorMap.set('TokenCloseFailed', TmTokenCloseFailedError);

/** UnsizedCollection: 'Can't use this function on unsized collection' */
export class TmUnsizedCollectionError extends ProgramError {
  readonly name: string = 'UnsizedCollection';

  readonly code: number = 0x65; // 101

  constructor(program: Program, cause?: Error) {
    super("Can't use this function on unsized collection", program, cause);
  }
}
codeToErrorMap.set(0x65, TmUnsizedCollectionError);
nameToErrorMap.set('UnsizedCollection', TmUnsizedCollectionError);

/** SizedCollection: 'Can't use this function on a sized collection' */
export class TmSizedCollectionError extends ProgramError {
  readonly name: string = 'SizedCollection';

  readonly code: number = 0x66; // 102

  constructor(program: Program, cause?: Error) {
    super("Can't use this function on a sized collection", program, cause);
  }
}
codeToErrorMap.set(0x66, TmSizedCollectionError);
nameToErrorMap.set('SizedCollection', TmSizedCollectionError);

/** MissingCollectionMetadata: 'Can't burn a verified member of a collection w/o providing collection metadata account' */
export class TmMissingCollectionMetadataError extends ProgramError {
  readonly name: string = 'MissingCollectionMetadata';

  readonly code: number = 0x67; // 103

  constructor(program: Program, cause?: Error) {
    super(
      "Can't burn a verified member of a collection w/o providing collection metadata account",
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x67, TmMissingCollectionMetadataError);
nameToErrorMap.set(
  'MissingCollectionMetadata',
  TmMissingCollectionMetadataError
);

/** NotAMemberOfCollection: 'This NFT is not a member of the specified collection.' */
export class TmNotAMemberOfCollectionError extends ProgramError {
  readonly name: string = 'NotAMemberOfCollection';

  readonly code: number = 0x68; // 104

  constructor(program: Program, cause?: Error) {
    super(
      'This NFT is not a member of the specified collection.',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x68, TmNotAMemberOfCollectionError);
nameToErrorMap.set('NotAMemberOfCollection', TmNotAMemberOfCollectionError);

/** NotVerifiedMemberOfCollection: 'This NFT is not a verified member of the specified collection.' */
export class TmNotVerifiedMemberOfCollectionError extends ProgramError {
  readonly name: string = 'NotVerifiedMemberOfCollection';

  readonly code: number = 0x69; // 105

  constructor(program: Program, cause?: Error) {
    super(
      'This NFT is not a verified member of the specified collection.',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x69, TmNotVerifiedMemberOfCollectionError);
nameToErrorMap.set(
  'NotVerifiedMemberOfCollection',
  TmNotVerifiedMemberOfCollectionError
);

/** NotACollectionParent: 'This NFT is not a collection parent NFT.' */
export class TmNotACollectionParentError extends ProgramError {
  readonly name: string = 'NotACollectionParent';

  readonly code: number = 0x6a; // 106

  constructor(program: Program, cause?: Error) {
    super('This NFT is not a collection parent NFT.', program, cause);
  }
}
codeToErrorMap.set(0x6a, TmNotACollectionParentError);
nameToErrorMap.set('NotACollectionParent', TmNotACollectionParentError);

/** CouldNotDetermineTokenStandard: 'Could not determine a TokenStandard type.' */
export class TmCouldNotDetermineTokenStandardError extends ProgramError {
  readonly name: string = 'CouldNotDetermineTokenStandard';

  readonly code: number = 0x6b; // 107

  constructor(program: Program, cause?: Error) {
    super('Could not determine a TokenStandard type.', program, cause);
  }
}
codeToErrorMap.set(0x6b, TmCouldNotDetermineTokenStandardError);
nameToErrorMap.set(
  'CouldNotDetermineTokenStandard',
  TmCouldNotDetermineTokenStandardError
);

/** MissingEditionAccount: 'This mint account has an edition but none was provided.' */
export class TmMissingEditionAccountError extends ProgramError {
  readonly name: string = 'MissingEditionAccount';

  readonly code: number = 0x6c; // 108

  constructor(program: Program, cause?: Error) {
    super(
      'This mint account has an edition but none was provided.',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x6c, TmMissingEditionAccountError);
nameToErrorMap.set('MissingEditionAccount', TmMissingEditionAccountError);

/** NotAMasterEdition: 'This edition is not a Master Edition' */
export class TmNotAMasterEditionError extends ProgramError {
  readonly name: string = 'NotAMasterEdition';

  readonly code: number = 0x6d; // 109

  constructor(program: Program, cause?: Error) {
    super('This edition is not a Master Edition', program, cause);
  }
}
codeToErrorMap.set(0x6d, TmNotAMasterEditionError);
nameToErrorMap.set('NotAMasterEdition', TmNotAMasterEditionError);

/** MasterEditionHasPrints: 'This Master Edition has existing prints' */
export class TmMasterEditionHasPrintsError extends ProgramError {
  readonly name: string = 'MasterEditionHasPrints';

  readonly code: number = 0x6e; // 110

  constructor(program: Program, cause?: Error) {
    super('This Master Edition has existing prints', program, cause);
  }
}
codeToErrorMap.set(0x6e, TmMasterEditionHasPrintsError);
nameToErrorMap.set('MasterEditionHasPrints', TmMasterEditionHasPrintsError);

/** BorshDeserializationError: 'Borsh Deserialization Error' */
export class TmBorshDeserializationErrorError extends ProgramError {
  readonly name: string = 'BorshDeserializationError';

  readonly code: number = 0x6f; // 111

  constructor(program: Program, cause?: Error) {
    super('Borsh Deserialization Error', program, cause);
  }
}
codeToErrorMap.set(0x6f, TmBorshDeserializationErrorError);
nameToErrorMap.set(
  'BorshDeserializationError',
  TmBorshDeserializationErrorError
);

/** CannotUpdateVerifiedCollection: 'Cannot update a verified colleciton in this command' */
export class TmCannotUpdateVerifiedCollectionError extends ProgramError {
  readonly name: string = 'CannotUpdateVerifiedCollection';

  readonly code: number = 0x70; // 112

  constructor(program: Program, cause?: Error) {
    super(
      'Cannot update a verified colleciton in this command',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x70, TmCannotUpdateVerifiedCollectionError);
nameToErrorMap.set(
  'CannotUpdateVerifiedCollection',
  TmCannotUpdateVerifiedCollectionError
);

/** CollectionMasterEditionAccountInvalid: 'Edition account doesnt match collection ' */
export class TmCollectionMasterEditionAccountInvalidError extends ProgramError {
  readonly name: string = 'CollectionMasterEditionAccountInvalid';

  readonly code: number = 0x71; // 113

  constructor(program: Program, cause?: Error) {
    super('Edition account doesnt match collection ', program, cause);
  }
}
codeToErrorMap.set(0x71, TmCollectionMasterEditionAccountInvalidError);
nameToErrorMap.set(
  'CollectionMasterEditionAccountInvalid',
  TmCollectionMasterEditionAccountInvalidError
);

/** AlreadyVerified: 'Item is already verified.' */
export class TmAlreadyVerifiedError extends ProgramError {
  readonly name: string = 'AlreadyVerified';

  readonly code: number = 0x72; // 114

  constructor(program: Program, cause?: Error) {
    super('Item is already verified.', program, cause);
  }
}
codeToErrorMap.set(0x72, TmAlreadyVerifiedError);
nameToErrorMap.set('AlreadyVerified', TmAlreadyVerifiedError);

/** AlreadyUnverified: 'Item is already unverified.' */
export class TmAlreadyUnverifiedError extends ProgramError {
  readonly name: string = 'AlreadyUnverified';

  readonly code: number = 0x73; // 115

  constructor(program: Program, cause?: Error) {
    super('Item is already unverified.', program, cause);
  }
}
codeToErrorMap.set(0x73, TmAlreadyUnverifiedError);
nameToErrorMap.set('AlreadyUnverified', TmAlreadyUnverifiedError);

/** NotAPrintEdition: 'This edition is not a Print Edition' */
export class TmNotAPrintEditionError extends ProgramError {
  readonly name: string = 'NotAPrintEdition';

  readonly code: number = 0x74; // 116

  constructor(program: Program, cause?: Error) {
    super('This edition is not a Print Edition', program, cause);
  }
}
codeToErrorMap.set(0x74, TmNotAPrintEditionError);
nameToErrorMap.set('NotAPrintEdition', TmNotAPrintEditionError);

/** InvalidMasterEdition: 'Invalid Master Edition' */
export class TmInvalidMasterEditionError extends ProgramError {
  readonly name: string = 'InvalidMasterEdition';

  readonly code: number = 0x75; // 117

  constructor(program: Program, cause?: Error) {
    super('Invalid Master Edition', program, cause);
  }
}
codeToErrorMap.set(0x75, TmInvalidMasterEditionError);
nameToErrorMap.set('InvalidMasterEdition', TmInvalidMasterEditionError);

/** InvalidPrintEdition: 'Invalid Print Edition' */
export class TmInvalidPrintEditionError extends ProgramError {
  readonly name: string = 'InvalidPrintEdition';

  readonly code: number = 0x76; // 118

  constructor(program: Program, cause?: Error) {
    super('Invalid Print Edition', program, cause);
  }
}
codeToErrorMap.set(0x76, TmInvalidPrintEditionError);
nameToErrorMap.set('InvalidPrintEdition', TmInvalidPrintEditionError);

/** InvalidEditionMarker: 'Invalid Edition Marker' */
export class TmInvalidEditionMarkerError extends ProgramError {
  readonly name: string = 'InvalidEditionMarker';

  readonly code: number = 0x77; // 119

  constructor(program: Program, cause?: Error) {
    super('Invalid Edition Marker', program, cause);
  }
}
codeToErrorMap.set(0x77, TmInvalidEditionMarkerError);
nameToErrorMap.set('InvalidEditionMarker', TmInvalidEditionMarkerError);

/** ReservationListDeprecated: 'Reservation List is Deprecated' */
export class TmReservationListDeprecatedError extends ProgramError {
  readonly name: string = 'ReservationListDeprecated';

  readonly code: number = 0x78; // 120

  constructor(program: Program, cause?: Error) {
    super('Reservation List is Deprecated', program, cause);
  }
}
codeToErrorMap.set(0x78, TmReservationListDeprecatedError);
nameToErrorMap.set(
  'ReservationListDeprecated',
  TmReservationListDeprecatedError
);

/** PrintEditionDoesNotMatchMasterEdition: 'Print Edition does not match Master Edition' */
export class TmPrintEditionDoesNotMatchMasterEditionError extends ProgramError {
  readonly name: string = 'PrintEditionDoesNotMatchMasterEdition';

  readonly code: number = 0x79; // 121

  constructor(program: Program, cause?: Error) {
    super('Print Edition does not match Master Edition', program, cause);
  }
}
codeToErrorMap.set(0x79, TmPrintEditionDoesNotMatchMasterEditionError);
nameToErrorMap.set(
  'PrintEditionDoesNotMatchMasterEdition',
  TmPrintEditionDoesNotMatchMasterEditionError
);

/** EditionNumberGreaterThanMaxSupply: 'Edition Number greater than max supply' */
export class TmEditionNumberGreaterThanMaxSupplyError extends ProgramError {
  readonly name: string = 'EditionNumberGreaterThanMaxSupply';

  readonly code: number = 0x7a; // 122

  constructor(program: Program, cause?: Error) {
    super('Edition Number greater than max supply', program, cause);
  }
}
codeToErrorMap.set(0x7a, TmEditionNumberGreaterThanMaxSupplyError);
nameToErrorMap.set(
  'EditionNumberGreaterThanMaxSupply',
  TmEditionNumberGreaterThanMaxSupplyError
);

/** MustUnverify: 'Must unverify before migrating collections.' */
export class TmMustUnverifyError extends ProgramError {
  readonly name: string = 'MustUnverify';

  readonly code: number = 0x7b; // 123

  constructor(program: Program, cause?: Error) {
    super('Must unverify before migrating collections.', program, cause);
  }
}
codeToErrorMap.set(0x7b, TmMustUnverifyError);
nameToErrorMap.set('MustUnverify', TmMustUnverifyError);

/** InvalidEscrowBumpSeed: 'Invalid Escrow Account Bump Seed' */
export class TmInvalidEscrowBumpSeedError extends ProgramError {
  readonly name: string = 'InvalidEscrowBumpSeed';

  readonly code: number = 0x7c; // 124

  constructor(program: Program, cause?: Error) {
    super('Invalid Escrow Account Bump Seed', program, cause);
  }
}
codeToErrorMap.set(0x7c, TmInvalidEscrowBumpSeedError);
nameToErrorMap.set('InvalidEscrowBumpSeed', TmInvalidEscrowBumpSeedError);

/** MustBeEscrowAuthority: 'Must Escrow Authority' */
export class TmMustBeEscrowAuthorityError extends ProgramError {
  readonly name: string = 'MustBeEscrowAuthority';

  readonly code: number = 0x7d; // 125

  constructor(program: Program, cause?: Error) {
    super('Must Escrow Authority', program, cause);
  }
}
codeToErrorMap.set(0x7d, TmMustBeEscrowAuthorityError);
nameToErrorMap.set('MustBeEscrowAuthority', TmMustBeEscrowAuthorityError);

/** InvalidSystemProgram: 'Invalid System Program' */
export class TmInvalidSystemProgramError extends ProgramError {
  readonly name: string = 'InvalidSystemProgram';

  readonly code: number = 0x7e; // 126

  constructor(program: Program, cause?: Error) {
    super('Invalid System Program', program, cause);
  }
}
codeToErrorMap.set(0x7e, TmInvalidSystemProgramError);
nameToErrorMap.set('InvalidSystemProgram', TmInvalidSystemProgramError);

/** MustBeNonFungible: 'Must be a Non Fungible Token' */
export class TmMustBeNonFungibleError extends ProgramError {
  readonly name: string = 'MustBeNonFungible';

  readonly code: number = 0x7f; // 127

  constructor(program: Program, cause?: Error) {
    super('Must be a Non Fungible Token', program, cause);
  }
}
codeToErrorMap.set(0x7f, TmMustBeNonFungibleError);
nameToErrorMap.set('MustBeNonFungible', TmMustBeNonFungibleError);

/** InsufficientTokens: 'Insufficient tokens for transfer' */
export class TmInsufficientTokensError extends ProgramError {
  readonly name: string = 'InsufficientTokens';

  readonly code: number = 0x80; // 128

  constructor(program: Program, cause?: Error) {
    super('Insufficient tokens for transfer', program, cause);
  }
}
codeToErrorMap.set(0x80, TmInsufficientTokensError);
nameToErrorMap.set('InsufficientTokens', TmInsufficientTokensError);

/** BorshSerializationError: 'Borsh Serialization Error' */
export class TmBorshSerializationErrorError extends ProgramError {
  readonly name: string = 'BorshSerializationError';

  readonly code: number = 0x81; // 129

  constructor(program: Program, cause?: Error) {
    super('Borsh Serialization Error', program, cause);
  }
}
codeToErrorMap.set(0x81, TmBorshSerializationErrorError);
nameToErrorMap.set('BorshSerializationError', TmBorshSerializationErrorError);

/** NoFreezeAuthoritySet: 'Cannot create NFT with no Freeze Authority.' */
export class TmNoFreezeAuthoritySetError extends ProgramError {
  readonly name: string = 'NoFreezeAuthoritySet';

  readonly code: number = 0x82; // 130

  constructor(program: Program, cause?: Error) {
    super('Cannot create NFT with no Freeze Authority.', program, cause);
  }
}
codeToErrorMap.set(0x82, TmNoFreezeAuthoritySetError);
nameToErrorMap.set('NoFreezeAuthoritySet', TmNoFreezeAuthoritySetError);

/** InvalidCollectionSizeChange: 'Invalid collection size change' */
export class TmInvalidCollectionSizeChangeError extends ProgramError {
  readonly name: string = 'InvalidCollectionSizeChange';

  readonly code: number = 0x83; // 131

  constructor(program: Program, cause?: Error) {
    super('Invalid collection size change', program, cause);
  }
}
codeToErrorMap.set(0x83, TmInvalidCollectionSizeChangeError);
nameToErrorMap.set(
  'InvalidCollectionSizeChange',
  TmInvalidCollectionSizeChangeError
);

/** InvalidBubblegumSigner: 'Invalid bubblegum signer' */
export class TmInvalidBubblegumSignerError extends ProgramError {
  readonly name: string = 'InvalidBubblegumSigner';

  readonly code: number = 0x84; // 132

  constructor(program: Program, cause?: Error) {
    super('Invalid bubblegum signer', program, cause);
  }
}
codeToErrorMap.set(0x84, TmInvalidBubblegumSignerError);
nameToErrorMap.set('InvalidBubblegumSigner', TmInvalidBubblegumSignerError);

/** EscrowParentHasDelegate: 'Escrow parent cannot have a delegate' */
export class TmEscrowParentHasDelegateError extends ProgramError {
  readonly name: string = 'EscrowParentHasDelegate';

  readonly code: number = 0x85; // 133

  constructor(program: Program, cause?: Error) {
    super('Escrow parent cannot have a delegate', program, cause);
  }
}
codeToErrorMap.set(0x85, TmEscrowParentHasDelegateError);
nameToErrorMap.set('EscrowParentHasDelegate', TmEscrowParentHasDelegateError);

/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 */
export function getMplTokenMetadataErrorFromCode(
  code: number,
  program: Program,
  cause?: Error
): ProgramError | null {
  const constructor = codeToErrorMap.get(code);
  return constructor ? new constructor(program, cause) : null;
}

/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 */
export function getMplTokenMetadataErrorFromName(
  name: string,
  program: Program,
  cause?: Error
): ProgramError | null {
  const constructor = nameToErrorMap.get(name);
  return constructor ? new constructor(program, cause) : null;
}
