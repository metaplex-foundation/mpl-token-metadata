/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */

import { Program, ProgramError } from '@metaplex-foundation/umi';

type ProgramErrorConstructor = new (
  program: Program,
  cause?: Error
) => ProgramError;
const codeToErrorMap: Map<number, ProgramErrorConstructor> = new Map();
const nameToErrorMap: Map<string, ProgramErrorConstructor> = new Map();

/** InstructionUnpackError */
export class InstructionUnpackErrorError extends ProgramError {
  readonly name: string = 'InstructionUnpackError';

  readonly code: number = 0x0; // 0

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x0, InstructionUnpackErrorError);
nameToErrorMap.set('InstructionUnpackError', InstructionUnpackErrorError);

/** InstructionPackError */
export class InstructionPackErrorError extends ProgramError {
  readonly name: string = 'InstructionPackError';

  readonly code: number = 0x1; // 1

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x1, InstructionPackErrorError);
nameToErrorMap.set('InstructionPackError', InstructionPackErrorError);

/** NotRentExempt: Lamport balance below rent-exempt threshold */
export class NotRentExemptError extends ProgramError {
  readonly name: string = 'NotRentExempt';

  readonly code: number = 0x2; // 2

  constructor(program: Program, cause?: Error) {
    super('Lamport balance below rent-exempt threshold', program, cause);
  }
}
codeToErrorMap.set(0x2, NotRentExemptError);
nameToErrorMap.set('NotRentExempt', NotRentExemptError);

/** AlreadyInitialized: Already initialized */
export class AlreadyInitializedError extends ProgramError {
  readonly name: string = 'AlreadyInitialized';

  readonly code: number = 0x3; // 3

  constructor(program: Program, cause?: Error) {
    super('Already initialized', program, cause);
  }
}
codeToErrorMap.set(0x3, AlreadyInitializedError);
nameToErrorMap.set('AlreadyInitialized', AlreadyInitializedError);

/** Uninitialized: Uninitialized */
export class UninitializedError extends ProgramError {
  readonly name: string = 'Uninitialized';

  readonly code: number = 0x4; // 4

  constructor(program: Program, cause?: Error) {
    super('Uninitialized', program, cause);
  }
}
codeToErrorMap.set(0x4, UninitializedError);
nameToErrorMap.set('Uninitialized', UninitializedError);

/** InvalidMetadataKey:  Metadata's key must match seed of ['metadata', program id, mint] provided */
export class InvalidMetadataKeyError extends ProgramError {
  readonly name: string = 'InvalidMetadataKey';

  readonly code: number = 0x5; // 5

  constructor(program: Program, cause?: Error) {
    super(
      " Metadata's key must match seed of ['metadata', program id, mint] provided",
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x5, InvalidMetadataKeyError);
nameToErrorMap.set('InvalidMetadataKey', InvalidMetadataKeyError);

/** InvalidEditionKey: Edition's key must match seed of ['metadata', program id, name, 'edition'] provided */
export class InvalidEditionKeyError extends ProgramError {
  readonly name: string = 'InvalidEditionKey';

  readonly code: number = 0x6; // 6

  constructor(program: Program, cause?: Error) {
    super(
      "Edition's key must match seed of ['metadata', program id, name, 'edition'] provided",
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x6, InvalidEditionKeyError);
nameToErrorMap.set('InvalidEditionKey', InvalidEditionKeyError);

/** UpdateAuthorityIncorrect: Update Authority given does not match */
export class UpdateAuthorityIncorrectError extends ProgramError {
  readonly name: string = 'UpdateAuthorityIncorrect';

  readonly code: number = 0x7; // 7

  constructor(program: Program, cause?: Error) {
    super('Update Authority given does not match', program, cause);
  }
}
codeToErrorMap.set(0x7, UpdateAuthorityIncorrectError);
nameToErrorMap.set('UpdateAuthorityIncorrect', UpdateAuthorityIncorrectError);

/** UpdateAuthorityIsNotSigner: Update Authority needs to be signer to update metadata */
export class UpdateAuthorityIsNotSignerError extends ProgramError {
  readonly name: string = 'UpdateAuthorityIsNotSigner';

  readonly code: number = 0x8; // 8

  constructor(program: Program, cause?: Error) {
    super(
      'Update Authority needs to be signer to update metadata',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x8, UpdateAuthorityIsNotSignerError);
nameToErrorMap.set(
  'UpdateAuthorityIsNotSigner',
  UpdateAuthorityIsNotSignerError
);

/** NotMintAuthority: You must be the mint authority and signer on this transaction */
export class NotMintAuthorityError extends ProgramError {
  readonly name: string = 'NotMintAuthority';

  readonly code: number = 0x9; // 9

  constructor(program: Program, cause?: Error) {
    super(
      'You must be the mint authority and signer on this transaction',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x9, NotMintAuthorityError);
nameToErrorMap.set('NotMintAuthority', NotMintAuthorityError);

/** InvalidMintAuthority: Mint authority provided does not match the authority on the mint */
export class InvalidMintAuthorityError extends ProgramError {
  readonly name: string = 'InvalidMintAuthority';

  readonly code: number = 0xa; // 10

  constructor(program: Program, cause?: Error) {
    super(
      'Mint authority provided does not match the authority on the mint',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0xa, InvalidMintAuthorityError);
nameToErrorMap.set('InvalidMintAuthority', InvalidMintAuthorityError);

/** NameTooLong: Name too long */
export class NameTooLongError extends ProgramError {
  readonly name: string = 'NameTooLong';

  readonly code: number = 0xb; // 11

  constructor(program: Program, cause?: Error) {
    super('Name too long', program, cause);
  }
}
codeToErrorMap.set(0xb, NameTooLongError);
nameToErrorMap.set('NameTooLong', NameTooLongError);

/** SymbolTooLong: Symbol too long */
export class SymbolTooLongError extends ProgramError {
  readonly name: string = 'SymbolTooLong';

  readonly code: number = 0xc; // 12

  constructor(program: Program, cause?: Error) {
    super('Symbol too long', program, cause);
  }
}
codeToErrorMap.set(0xc, SymbolTooLongError);
nameToErrorMap.set('SymbolTooLong', SymbolTooLongError);

/** UriTooLong: URI too long */
export class UriTooLongError extends ProgramError {
  readonly name: string = 'UriTooLong';

  readonly code: number = 0xd; // 13

  constructor(program: Program, cause?: Error) {
    super('URI too long', program, cause);
  }
}
codeToErrorMap.set(0xd, UriTooLongError);
nameToErrorMap.set('UriTooLong', UriTooLongError);

/** UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner */
export class UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError extends ProgramError {
  readonly name: string =
    'UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner';

  readonly code: number = 0xe; // 14

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(
  0xe,
  UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError
);
nameToErrorMap.set(
  'UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner',
  UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError
);

/** MintMismatch: Mint given does not match mint on Metadata */
export class MintMismatchError extends ProgramError {
  readonly name: string = 'MintMismatch';

  readonly code: number = 0xf; // 15

  constructor(program: Program, cause?: Error) {
    super('Mint given does not match mint on Metadata', program, cause);
  }
}
codeToErrorMap.set(0xf, MintMismatchError);
nameToErrorMap.set('MintMismatch', MintMismatchError);

/** EditionsMustHaveExactlyOneToken: Editions must have exactly one token */
export class EditionsMustHaveExactlyOneTokenError extends ProgramError {
  readonly name: string = 'EditionsMustHaveExactlyOneToken';

  readonly code: number = 0x10; // 16

  constructor(program: Program, cause?: Error) {
    super('Editions must have exactly one token', program, cause);
  }
}
codeToErrorMap.set(0x10, EditionsMustHaveExactlyOneTokenError);
nameToErrorMap.set(
  'EditionsMustHaveExactlyOneToken',
  EditionsMustHaveExactlyOneTokenError
);

/** MaxEditionsMintedAlready */
export class MaxEditionsMintedAlreadyError extends ProgramError {
  readonly name: string = 'MaxEditionsMintedAlready';

  readonly code: number = 0x11; // 17

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x11, MaxEditionsMintedAlreadyError);
nameToErrorMap.set('MaxEditionsMintedAlready', MaxEditionsMintedAlreadyError);

/** TokenMintToFailed */
export class TokenMintToFailedError extends ProgramError {
  readonly name: string = 'TokenMintToFailed';

  readonly code: number = 0x12; // 18

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x12, TokenMintToFailedError);
nameToErrorMap.set('TokenMintToFailed', TokenMintToFailedError);

/** MasterRecordMismatch */
export class MasterRecordMismatchError extends ProgramError {
  readonly name: string = 'MasterRecordMismatch';

  readonly code: number = 0x13; // 19

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x13, MasterRecordMismatchError);
nameToErrorMap.set('MasterRecordMismatch', MasterRecordMismatchError);

/** DestinationMintMismatch */
export class DestinationMintMismatchError extends ProgramError {
  readonly name: string = 'DestinationMintMismatch';

  readonly code: number = 0x14; // 20

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x14, DestinationMintMismatchError);
nameToErrorMap.set('DestinationMintMismatch', DestinationMintMismatchError);

/** EditionAlreadyMinted */
export class EditionAlreadyMintedError extends ProgramError {
  readonly name: string = 'EditionAlreadyMinted';

  readonly code: number = 0x15; // 21

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x15, EditionAlreadyMintedError);
nameToErrorMap.set('EditionAlreadyMinted', EditionAlreadyMintedError);

/** PrintingMintDecimalsShouldBeZero */
export class PrintingMintDecimalsShouldBeZeroError extends ProgramError {
  readonly name: string = 'PrintingMintDecimalsShouldBeZero';

  readonly code: number = 0x16; // 22

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x16, PrintingMintDecimalsShouldBeZeroError);
nameToErrorMap.set(
  'PrintingMintDecimalsShouldBeZero',
  PrintingMintDecimalsShouldBeZeroError
);

/** OneTimePrintingAuthorizationMintDecimalsShouldBeZero */
export class OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError extends ProgramError {
  readonly name: string =
    'OneTimePrintingAuthorizationMintDecimalsShouldBeZero';

  readonly code: number = 0x17; // 23

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(
  0x17,
  OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError
);
nameToErrorMap.set(
  'OneTimePrintingAuthorizationMintDecimalsShouldBeZero',
  OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError
);

/** EditionMintDecimalsShouldBeZero: EditionMintDecimalsShouldBeZero */
export class EditionMintDecimalsShouldBeZeroError extends ProgramError {
  readonly name: string = 'EditionMintDecimalsShouldBeZero';

  readonly code: number = 0x18; // 24

  constructor(program: Program, cause?: Error) {
    super('EditionMintDecimalsShouldBeZero', program, cause);
  }
}
codeToErrorMap.set(0x18, EditionMintDecimalsShouldBeZeroError);
nameToErrorMap.set(
  'EditionMintDecimalsShouldBeZero',
  EditionMintDecimalsShouldBeZeroError
);

/** TokenBurnFailed */
export class TokenBurnFailedError extends ProgramError {
  readonly name: string = 'TokenBurnFailed';

  readonly code: number = 0x19; // 25

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x19, TokenBurnFailedError);
nameToErrorMap.set('TokenBurnFailed', TokenBurnFailedError);

/** TokenAccountOneTimeAuthMintMismatch */
export class TokenAccountOneTimeAuthMintMismatchError extends ProgramError {
  readonly name: string = 'TokenAccountOneTimeAuthMintMismatch';

  readonly code: number = 0x1a; // 26

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x1a, TokenAccountOneTimeAuthMintMismatchError);
nameToErrorMap.set(
  'TokenAccountOneTimeAuthMintMismatch',
  TokenAccountOneTimeAuthMintMismatchError
);

/** DerivedKeyInvalid: Derived key invalid */
export class DerivedKeyInvalidError extends ProgramError {
  readonly name: string = 'DerivedKeyInvalid';

  readonly code: number = 0x1b; // 27

  constructor(program: Program, cause?: Error) {
    super('Derived key invalid', program, cause);
  }
}
codeToErrorMap.set(0x1b, DerivedKeyInvalidError);
nameToErrorMap.set('DerivedKeyInvalid', DerivedKeyInvalidError);

/** PrintingMintMismatch: The Printing mint does not match that on the master edition! */
export class PrintingMintMismatchError extends ProgramError {
  readonly name: string = 'PrintingMintMismatch';

  readonly code: number = 0x1c; // 28

  constructor(program: Program, cause?: Error) {
    super(
      'The Printing mint does not match that on the master edition!',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x1c, PrintingMintMismatchError);
nameToErrorMap.set('PrintingMintMismatch', PrintingMintMismatchError);

/** OneTimePrintingAuthMintMismatch: The One Time Printing Auth mint does not match that on the master edition! */
export class OneTimePrintingAuthMintMismatchError extends ProgramError {
  readonly name: string = 'OneTimePrintingAuthMintMismatch';

  readonly code: number = 0x1d; // 29

  constructor(program: Program, cause?: Error) {
    super(
      'The One Time Printing Auth mint does not match that on the master edition!',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x1d, OneTimePrintingAuthMintMismatchError);
nameToErrorMap.set(
  'OneTimePrintingAuthMintMismatch',
  OneTimePrintingAuthMintMismatchError
);

/** TokenAccountMintMismatch: The mint of the token account does not match the Printing mint! */
export class TokenAccountMintMismatchError extends ProgramError {
  readonly name: string = 'TokenAccountMintMismatch';

  readonly code: number = 0x1e; // 30

  constructor(program: Program, cause?: Error) {
    super(
      'The mint of the token account does not match the Printing mint!',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x1e, TokenAccountMintMismatchError);
nameToErrorMap.set('TokenAccountMintMismatch', TokenAccountMintMismatchError);

/** TokenAccountMintMismatchV2: The mint of the token account does not match the master metadata mint! */
export class TokenAccountMintMismatchV2Error extends ProgramError {
  readonly name: string = 'TokenAccountMintMismatchV2';

  readonly code: number = 0x1f; // 31

  constructor(program: Program, cause?: Error) {
    super(
      'The mint of the token account does not match the master metadata mint!',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x1f, TokenAccountMintMismatchV2Error);
nameToErrorMap.set(
  'TokenAccountMintMismatchV2',
  TokenAccountMintMismatchV2Error
);

/** NotEnoughTokens: Not enough tokens to mint a limited edition */
export class NotEnoughTokensError extends ProgramError {
  readonly name: string = 'NotEnoughTokens';

  readonly code: number = 0x20; // 32

  constructor(program: Program, cause?: Error) {
    super('Not enough tokens to mint a limited edition', program, cause);
  }
}
codeToErrorMap.set(0x20, NotEnoughTokensError);
nameToErrorMap.set('NotEnoughTokens', NotEnoughTokensError);

/** PrintingMintAuthorizationAccountMismatch */
export class PrintingMintAuthorizationAccountMismatchError extends ProgramError {
  readonly name: string = 'PrintingMintAuthorizationAccountMismatch';

  readonly code: number = 0x21; // 33

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x21, PrintingMintAuthorizationAccountMismatchError);
nameToErrorMap.set(
  'PrintingMintAuthorizationAccountMismatch',
  PrintingMintAuthorizationAccountMismatchError
);

/** AuthorizationTokenAccountOwnerMismatch */
export class AuthorizationTokenAccountOwnerMismatchError extends ProgramError {
  readonly name: string = 'AuthorizationTokenAccountOwnerMismatch';

  readonly code: number = 0x22; // 34

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x22, AuthorizationTokenAccountOwnerMismatchError);
nameToErrorMap.set(
  'AuthorizationTokenAccountOwnerMismatch',
  AuthorizationTokenAccountOwnerMismatchError
);

/** Disabled */
export class DisabledError extends ProgramError {
  readonly name: string = 'Disabled';

  readonly code: number = 0x23; // 35

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x23, DisabledError);
nameToErrorMap.set('Disabled', DisabledError);

/** CreatorsTooLong: Creators list too long */
export class CreatorsTooLongError extends ProgramError {
  readonly name: string = 'CreatorsTooLong';

  readonly code: number = 0x24; // 36

  constructor(program: Program, cause?: Error) {
    super('Creators list too long', program, cause);
  }
}
codeToErrorMap.set(0x24, CreatorsTooLongError);
nameToErrorMap.set('CreatorsTooLong', CreatorsTooLongError);

/** CreatorsMustBeAtleastOne: Creators must be at least one if set */
export class CreatorsMustBeAtleastOneError extends ProgramError {
  readonly name: string = 'CreatorsMustBeAtleastOne';

  readonly code: number = 0x25; // 37

  constructor(program: Program, cause?: Error) {
    super('Creators must be at least one if set', program, cause);
  }
}
codeToErrorMap.set(0x25, CreatorsMustBeAtleastOneError);
nameToErrorMap.set('CreatorsMustBeAtleastOne', CreatorsMustBeAtleastOneError);

/** MustBeOneOfCreators */
export class MustBeOneOfCreatorsError extends ProgramError {
  readonly name: string = 'MustBeOneOfCreators';

  readonly code: number = 0x26; // 38

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x26, MustBeOneOfCreatorsError);
nameToErrorMap.set('MustBeOneOfCreators', MustBeOneOfCreatorsError);

/** NoCreatorsPresentOnMetadata: This metadata does not have creators */
export class NoCreatorsPresentOnMetadataError extends ProgramError {
  readonly name: string = 'NoCreatorsPresentOnMetadata';

  readonly code: number = 0x27; // 39

  constructor(program: Program, cause?: Error) {
    super('This metadata does not have creators', program, cause);
  }
}
codeToErrorMap.set(0x27, NoCreatorsPresentOnMetadataError);
nameToErrorMap.set(
  'NoCreatorsPresentOnMetadata',
  NoCreatorsPresentOnMetadataError
);

/** CreatorNotFound: This creator address was not found */
export class CreatorNotFoundError extends ProgramError {
  readonly name: string = 'CreatorNotFound';

  readonly code: number = 0x28; // 40

  constructor(program: Program, cause?: Error) {
    super('This creator address was not found', program, cause);
  }
}
codeToErrorMap.set(0x28, CreatorNotFoundError);
nameToErrorMap.set('CreatorNotFound', CreatorNotFoundError);

/** InvalidBasisPoints: Basis points cannot be more than 10000 */
export class InvalidBasisPointsError extends ProgramError {
  readonly name: string = 'InvalidBasisPoints';

  readonly code: number = 0x29; // 41

  constructor(program: Program, cause?: Error) {
    super('Basis points cannot be more than 10000', program, cause);
  }
}
codeToErrorMap.set(0x29, InvalidBasisPointsError);
nameToErrorMap.set('InvalidBasisPoints', InvalidBasisPointsError);

/** PrimarySaleCanOnlyBeFlippedToTrue: Primary sale can only be flipped to true and is immutable */
export class PrimarySaleCanOnlyBeFlippedToTrueError extends ProgramError {
  readonly name: string = 'PrimarySaleCanOnlyBeFlippedToTrue';

  readonly code: number = 0x2a; // 42

  constructor(program: Program, cause?: Error) {
    super(
      'Primary sale can only be flipped to true and is immutable',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x2a, PrimarySaleCanOnlyBeFlippedToTrueError);
nameToErrorMap.set(
  'PrimarySaleCanOnlyBeFlippedToTrue',
  PrimarySaleCanOnlyBeFlippedToTrueError
);

/** OwnerMismatch: Owner does not match that on the account given */
export class OwnerMismatchError extends ProgramError {
  readonly name: string = 'OwnerMismatch';

  readonly code: number = 0x2b; // 43

  constructor(program: Program, cause?: Error) {
    super('Owner does not match that on the account given', program, cause);
  }
}
codeToErrorMap.set(0x2b, OwnerMismatchError);
nameToErrorMap.set('OwnerMismatch', OwnerMismatchError);

/** NoBalanceInAccountForAuthorization: This account has no tokens to be used for authorization */
export class NoBalanceInAccountForAuthorizationError extends ProgramError {
  readonly name: string = 'NoBalanceInAccountForAuthorization';

  readonly code: number = 0x2c; // 44

  constructor(program: Program, cause?: Error) {
    super(
      'This account has no tokens to be used for authorization',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x2c, NoBalanceInAccountForAuthorizationError);
nameToErrorMap.set(
  'NoBalanceInAccountForAuthorization',
  NoBalanceInAccountForAuthorizationError
);

/** ShareTotalMustBe100: Share total must equal 100 for creator array */
export class ShareTotalMustBe100Error extends ProgramError {
  readonly name: string = 'ShareTotalMustBe100';

  readonly code: number = 0x2d; // 45

  constructor(program: Program, cause?: Error) {
    super('Share total must equal 100 for creator array', program, cause);
  }
}
codeToErrorMap.set(0x2d, ShareTotalMustBe100Error);
nameToErrorMap.set('ShareTotalMustBe100', ShareTotalMustBe100Error);

/** ReservationExists */
export class ReservationExistsError extends ProgramError {
  readonly name: string = 'ReservationExists';

  readonly code: number = 0x2e; // 46

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x2e, ReservationExistsError);
nameToErrorMap.set('ReservationExists', ReservationExistsError);

/** ReservationDoesNotExist */
export class ReservationDoesNotExistError extends ProgramError {
  readonly name: string = 'ReservationDoesNotExist';

  readonly code: number = 0x2f; // 47

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x2f, ReservationDoesNotExistError);
nameToErrorMap.set('ReservationDoesNotExist', ReservationDoesNotExistError);

/** ReservationNotSet */
export class ReservationNotSetError extends ProgramError {
  readonly name: string = 'ReservationNotSet';

  readonly code: number = 0x30; // 48

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x30, ReservationNotSetError);
nameToErrorMap.set('ReservationNotSet', ReservationNotSetError);

/** ReservationAlreadyMade */
export class ReservationAlreadyMadeError extends ProgramError {
  readonly name: string = 'ReservationAlreadyMade';

  readonly code: number = 0x31; // 49

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x31, ReservationAlreadyMadeError);
nameToErrorMap.set('ReservationAlreadyMade', ReservationAlreadyMadeError);

/** BeyondMaxAddressSize */
export class BeyondMaxAddressSizeError extends ProgramError {
  readonly name: string = 'BeyondMaxAddressSize';

  readonly code: number = 0x32; // 50

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x32, BeyondMaxAddressSizeError);
nameToErrorMap.set('BeyondMaxAddressSize', BeyondMaxAddressSizeError);

/** NumericalOverflowError: NumericalOverflowError */
export class NumericalOverflowErrorError extends ProgramError {
  readonly name: string = 'NumericalOverflowError';

  readonly code: number = 0x33; // 51

  constructor(program: Program, cause?: Error) {
    super('NumericalOverflowError', program, cause);
  }
}
codeToErrorMap.set(0x33, NumericalOverflowErrorError);
nameToErrorMap.set('NumericalOverflowError', NumericalOverflowErrorError);

/** ReservationBreachesMaximumSupply */
export class ReservationBreachesMaximumSupplyError extends ProgramError {
  readonly name: string = 'ReservationBreachesMaximumSupply';

  readonly code: number = 0x34; // 52

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x34, ReservationBreachesMaximumSupplyError);
nameToErrorMap.set(
  'ReservationBreachesMaximumSupply',
  ReservationBreachesMaximumSupplyError
);

/** AddressNotInReservation */
export class AddressNotInReservationError extends ProgramError {
  readonly name: string = 'AddressNotInReservation';

  readonly code: number = 0x35; // 53

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x35, AddressNotInReservationError);
nameToErrorMap.set('AddressNotInReservation', AddressNotInReservationError);

/** CannotVerifyAnotherCreator: You cannot unilaterally verify another creator, they must sign */
export class CannotVerifyAnotherCreatorError extends ProgramError {
  readonly name: string = 'CannotVerifyAnotherCreator';

  readonly code: number = 0x36; // 54

  constructor(program: Program, cause?: Error) {
    super(
      'You cannot unilaterally verify another creator, they must sign',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x36, CannotVerifyAnotherCreatorError);
nameToErrorMap.set(
  'CannotVerifyAnotherCreator',
  CannotVerifyAnotherCreatorError
);

/** CannotUnverifyAnotherCreator: You cannot unilaterally unverify another creator */
export class CannotUnverifyAnotherCreatorError extends ProgramError {
  readonly name: string = 'CannotUnverifyAnotherCreator';

  readonly code: number = 0x37; // 55

  constructor(program: Program, cause?: Error) {
    super('You cannot unilaterally unverify another creator', program, cause);
  }
}
codeToErrorMap.set(0x37, CannotUnverifyAnotherCreatorError);
nameToErrorMap.set(
  'CannotUnverifyAnotherCreator',
  CannotUnverifyAnotherCreatorError
);

/** SpotMismatch */
export class SpotMismatchError extends ProgramError {
  readonly name: string = 'SpotMismatch';

  readonly code: number = 0x38; // 56

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x38, SpotMismatchError);
nameToErrorMap.set('SpotMismatch', SpotMismatchError);

/** IncorrectOwner: Incorrect account owner */
export class IncorrectOwnerError extends ProgramError {
  readonly name: string = 'IncorrectOwner';

  readonly code: number = 0x39; // 57

  constructor(program: Program, cause?: Error) {
    super('Incorrect account owner', program, cause);
  }
}
codeToErrorMap.set(0x39, IncorrectOwnerError);
nameToErrorMap.set('IncorrectOwner', IncorrectOwnerError);

/** PrintingWouldBreachMaximumSupply */
export class PrintingWouldBreachMaximumSupplyError extends ProgramError {
  readonly name: string = 'PrintingWouldBreachMaximumSupply';

  readonly code: number = 0x3a; // 58

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x3a, PrintingWouldBreachMaximumSupplyError);
nameToErrorMap.set(
  'PrintingWouldBreachMaximumSupply',
  PrintingWouldBreachMaximumSupplyError
);

/** DataIsImmutable: Data is immutable */
export class DataIsImmutableError extends ProgramError {
  readonly name: string = 'DataIsImmutable';

  readonly code: number = 0x3b; // 59

  constructor(program: Program, cause?: Error) {
    super('Data is immutable', program, cause);
  }
}
codeToErrorMap.set(0x3b, DataIsImmutableError);
nameToErrorMap.set('DataIsImmutable', DataIsImmutableError);

/** DuplicateCreatorAddress: No duplicate creator addresses */
export class DuplicateCreatorAddressError extends ProgramError {
  readonly name: string = 'DuplicateCreatorAddress';

  readonly code: number = 0x3c; // 60

  constructor(program: Program, cause?: Error) {
    super('No duplicate creator addresses', program, cause);
  }
}
codeToErrorMap.set(0x3c, DuplicateCreatorAddressError);
nameToErrorMap.set('DuplicateCreatorAddress', DuplicateCreatorAddressError);

/** ReservationSpotsRemainingShouldMatchTotalSpotsAtStart */
export class ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError extends ProgramError {
  readonly name: string =
    'ReservationSpotsRemainingShouldMatchTotalSpotsAtStart';

  readonly code: number = 0x3d; // 61

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(
  0x3d,
  ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError
);
nameToErrorMap.set(
  'ReservationSpotsRemainingShouldMatchTotalSpotsAtStart',
  ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError
);

/** InvalidTokenProgram: Invalid token program */
export class InvalidTokenProgramError extends ProgramError {
  readonly name: string = 'InvalidTokenProgram';

  readonly code: number = 0x3e; // 62

  constructor(program: Program, cause?: Error) {
    super('Invalid token program', program, cause);
  }
}
codeToErrorMap.set(0x3e, InvalidTokenProgramError);
nameToErrorMap.set('InvalidTokenProgram', InvalidTokenProgramError);

/** DataTypeMismatch: Data type mismatch */
export class DataTypeMismatchError extends ProgramError {
  readonly name: string = 'DataTypeMismatch';

  readonly code: number = 0x3f; // 63

  constructor(program: Program, cause?: Error) {
    super('Data type mismatch', program, cause);
  }
}
codeToErrorMap.set(0x3f, DataTypeMismatchError);
nameToErrorMap.set('DataTypeMismatch', DataTypeMismatchError);

/** BeyondAlottedAddressSize */
export class BeyondAlottedAddressSizeError extends ProgramError {
  readonly name: string = 'BeyondAlottedAddressSize';

  readonly code: number = 0x40; // 64

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x40, BeyondAlottedAddressSizeError);
nameToErrorMap.set('BeyondAlottedAddressSize', BeyondAlottedAddressSizeError);

/** ReservationNotComplete */
export class ReservationNotCompleteError extends ProgramError {
  readonly name: string = 'ReservationNotComplete';

  readonly code: number = 0x41; // 65

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x41, ReservationNotCompleteError);
nameToErrorMap.set('ReservationNotComplete', ReservationNotCompleteError);

/** TriedToReplaceAnExistingReservation */
export class TriedToReplaceAnExistingReservationError extends ProgramError {
  readonly name: string = 'TriedToReplaceAnExistingReservation';

  readonly code: number = 0x42; // 66

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x42, TriedToReplaceAnExistingReservationError);
nameToErrorMap.set(
  'TriedToReplaceAnExistingReservation',
  TriedToReplaceAnExistingReservationError
);

/** InvalidOperation: Invalid operation */
export class InvalidOperationError extends ProgramError {
  readonly name: string = 'InvalidOperation';

  readonly code: number = 0x43; // 67

  constructor(program: Program, cause?: Error) {
    super('Invalid operation', program, cause);
  }
}
codeToErrorMap.set(0x43, InvalidOperationError);
nameToErrorMap.set('InvalidOperation', InvalidOperationError);

/** InvalidOwner: Invalid Owner */
export class InvalidOwnerError extends ProgramError {
  readonly name: string = 'InvalidOwner';

  readonly code: number = 0x44; // 68

  constructor(program: Program, cause?: Error) {
    super('Invalid Owner', program, cause);
  }
}
codeToErrorMap.set(0x44, InvalidOwnerError);
nameToErrorMap.set('InvalidOwner', InvalidOwnerError);

/** PrintingMintSupplyMustBeZeroForConversion: Printing mint supply must be zero for conversion */
export class PrintingMintSupplyMustBeZeroForConversionError extends ProgramError {
  readonly name: string = 'PrintingMintSupplyMustBeZeroForConversion';

  readonly code: number = 0x45; // 69

  constructor(program: Program, cause?: Error) {
    super('Printing mint supply must be zero for conversion', program, cause);
  }
}
codeToErrorMap.set(0x45, PrintingMintSupplyMustBeZeroForConversionError);
nameToErrorMap.set(
  'PrintingMintSupplyMustBeZeroForConversion',
  PrintingMintSupplyMustBeZeroForConversionError
);

/** OneTimeAuthMintSupplyMustBeZeroForConversion: One Time Auth mint supply must be zero for conversion */
export class OneTimeAuthMintSupplyMustBeZeroForConversionError extends ProgramError {
  readonly name: string = 'OneTimeAuthMintSupplyMustBeZeroForConversion';

  readonly code: number = 0x46; // 70

  constructor(program: Program, cause?: Error) {
    super(
      'One Time Auth mint supply must be zero for conversion',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x46, OneTimeAuthMintSupplyMustBeZeroForConversionError);
nameToErrorMap.set(
  'OneTimeAuthMintSupplyMustBeZeroForConversion',
  OneTimeAuthMintSupplyMustBeZeroForConversionError
);

/** InvalidEditionIndex: You tried to insert one edition too many into an edition mark pda */
export class InvalidEditionIndexError extends ProgramError {
  readonly name: string = 'InvalidEditionIndex';

  readonly code: number = 0x47; // 71

  constructor(program: Program, cause?: Error) {
    super(
      'You tried to insert one edition too many into an edition mark pda',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x47, InvalidEditionIndexError);
nameToErrorMap.set('InvalidEditionIndex', InvalidEditionIndexError);

/** ReservationArrayShouldBeSizeOne */
export class ReservationArrayShouldBeSizeOneError extends ProgramError {
  readonly name: string = 'ReservationArrayShouldBeSizeOne';

  readonly code: number = 0x48; // 72

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x48, ReservationArrayShouldBeSizeOneError);
nameToErrorMap.set(
  'ReservationArrayShouldBeSizeOne',
  ReservationArrayShouldBeSizeOneError
);

/** IsMutableCanOnlyBeFlippedToFalse: Is Mutable can only be flipped to false */
export class IsMutableCanOnlyBeFlippedToFalseError extends ProgramError {
  readonly name: string = 'IsMutableCanOnlyBeFlippedToFalse';

  readonly code: number = 0x49; // 73

  constructor(program: Program, cause?: Error) {
    super('Is Mutable can only be flipped to false', program, cause);
  }
}
codeToErrorMap.set(0x49, IsMutableCanOnlyBeFlippedToFalseError);
nameToErrorMap.set(
  'IsMutableCanOnlyBeFlippedToFalse',
  IsMutableCanOnlyBeFlippedToFalseError
);

/** CollectionCannotBeVerifiedInThisInstruction: Collection cannot be verified in this instruction */
export class CollectionCannotBeVerifiedInThisInstructionError extends ProgramError {
  readonly name: string = 'CollectionCannotBeVerifiedInThisInstruction';

  readonly code: number = 0x4a; // 74

  constructor(program: Program, cause?: Error) {
    super('Collection cannot be verified in this instruction', program, cause);
  }
}
codeToErrorMap.set(0x4a, CollectionCannotBeVerifiedInThisInstructionError);
nameToErrorMap.set(
  'CollectionCannotBeVerifiedInThisInstruction',
  CollectionCannotBeVerifiedInThisInstructionError
);

/** Removed: This instruction was deprecated in a previous release and is now removed */
export class RemovedError extends ProgramError {
  readonly name: string = 'Removed';

  readonly code: number = 0x4b; // 75

  constructor(program: Program, cause?: Error) {
    super(
      'This instruction was deprecated in a previous release and is now removed',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x4b, RemovedError);
nameToErrorMap.set('Removed', RemovedError);

/** MustBeBurned */
export class MustBeBurnedError extends ProgramError {
  readonly name: string = 'MustBeBurned';

  readonly code: number = 0x4c; // 76

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x4c, MustBeBurnedError);
nameToErrorMap.set('MustBeBurned', MustBeBurnedError);

/** InvalidUseMethod: This use method is invalid */
export class InvalidUseMethodError extends ProgramError {
  readonly name: string = 'InvalidUseMethod';

  readonly code: number = 0x4d; // 77

  constructor(program: Program, cause?: Error) {
    super('This use method is invalid', program, cause);
  }
}
codeToErrorMap.set(0x4d, InvalidUseMethodError);
nameToErrorMap.set('InvalidUseMethod', InvalidUseMethodError);

/** CannotChangeUseMethodAfterFirstUse: Cannot Change Use Method after the first use */
export class CannotChangeUseMethodAfterFirstUseError extends ProgramError {
  readonly name: string = 'CannotChangeUseMethodAfterFirstUse';

  readonly code: number = 0x4e; // 78

  constructor(program: Program, cause?: Error) {
    super('Cannot Change Use Method after the first use', program, cause);
  }
}
codeToErrorMap.set(0x4e, CannotChangeUseMethodAfterFirstUseError);
nameToErrorMap.set(
  'CannotChangeUseMethodAfterFirstUse',
  CannotChangeUseMethodAfterFirstUseError
);

/** CannotChangeUsesAfterFirstUse: Cannot Change Remaining or Available uses after the first use */
export class CannotChangeUsesAfterFirstUseError extends ProgramError {
  readonly name: string = 'CannotChangeUsesAfterFirstUse';

  readonly code: number = 0x4f; // 79

  constructor(program: Program, cause?: Error) {
    super(
      'Cannot Change Remaining or Available uses after the first use',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x4f, CannotChangeUsesAfterFirstUseError);
nameToErrorMap.set(
  'CannotChangeUsesAfterFirstUse',
  CannotChangeUsesAfterFirstUseError
);

/** CollectionNotFound: Collection Not Found on Metadata */
export class CollectionNotFoundError extends ProgramError {
  readonly name: string = 'CollectionNotFound';

  readonly code: number = 0x50; // 80

  constructor(program: Program, cause?: Error) {
    super('Collection Not Found on Metadata', program, cause);
  }
}
codeToErrorMap.set(0x50, CollectionNotFoundError);
nameToErrorMap.set('CollectionNotFound', CollectionNotFoundError);

/** InvalidCollectionUpdateAuthority: Collection Update Authority is invalid */
export class InvalidCollectionUpdateAuthorityError extends ProgramError {
  readonly name: string = 'InvalidCollectionUpdateAuthority';

  readonly code: number = 0x51; // 81

  constructor(program: Program, cause?: Error) {
    super('Collection Update Authority is invalid', program, cause);
  }
}
codeToErrorMap.set(0x51, InvalidCollectionUpdateAuthorityError);
nameToErrorMap.set(
  'InvalidCollectionUpdateAuthority',
  InvalidCollectionUpdateAuthorityError
);

/** CollectionMustBeAUniqueMasterEdition: Collection Must Be a Unique Master Edition v2 */
export class CollectionMustBeAUniqueMasterEditionError extends ProgramError {
  readonly name: string = 'CollectionMustBeAUniqueMasterEdition';

  readonly code: number = 0x52; // 82

  constructor(program: Program, cause?: Error) {
    super('Collection Must Be a Unique Master Edition v2', program, cause);
  }
}
codeToErrorMap.set(0x52, CollectionMustBeAUniqueMasterEditionError);
nameToErrorMap.set(
  'CollectionMustBeAUniqueMasterEdition',
  CollectionMustBeAUniqueMasterEditionError
);

/** UseAuthorityRecordAlreadyExists: The Use Authority Record Already Exists, to modify it Revoke, then Approve */
export class UseAuthorityRecordAlreadyExistsError extends ProgramError {
  readonly name: string = 'UseAuthorityRecordAlreadyExists';

  readonly code: number = 0x53; // 83

  constructor(program: Program, cause?: Error) {
    super(
      'The Use Authority Record Already Exists, to modify it Revoke, then Approve',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x53, UseAuthorityRecordAlreadyExistsError);
nameToErrorMap.set(
  'UseAuthorityRecordAlreadyExists',
  UseAuthorityRecordAlreadyExistsError
);

/** UseAuthorityRecordAlreadyRevoked: The Use Authority Record is empty or already revoked */
export class UseAuthorityRecordAlreadyRevokedError extends ProgramError {
  readonly name: string = 'UseAuthorityRecordAlreadyRevoked';

  readonly code: number = 0x54; // 84

  constructor(program: Program, cause?: Error) {
    super(
      'The Use Authority Record is empty or already revoked',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x54, UseAuthorityRecordAlreadyRevokedError);
nameToErrorMap.set(
  'UseAuthorityRecordAlreadyRevoked',
  UseAuthorityRecordAlreadyRevokedError
);

/** Unusable: This token has no uses */
export class UnusableError extends ProgramError {
  readonly name: string = 'Unusable';

  readonly code: number = 0x55; // 85

  constructor(program: Program, cause?: Error) {
    super('This token has no uses', program, cause);
  }
}
codeToErrorMap.set(0x55, UnusableError);
nameToErrorMap.set('Unusable', UnusableError);

/** NotEnoughUses: There are not enough Uses left on this token. */
export class NotEnoughUsesError extends ProgramError {
  readonly name: string = 'NotEnoughUses';

  readonly code: number = 0x56; // 86

  constructor(program: Program, cause?: Error) {
    super('There are not enough Uses left on this token.', program, cause);
  }
}
codeToErrorMap.set(0x56, NotEnoughUsesError);
nameToErrorMap.set('NotEnoughUses', NotEnoughUsesError);

/** CollectionAuthorityRecordAlreadyExists: This Collection Authority Record Already Exists. */
export class CollectionAuthorityRecordAlreadyExistsError extends ProgramError {
  readonly name: string = 'CollectionAuthorityRecordAlreadyExists';

  readonly code: number = 0x57; // 87

  constructor(program: Program, cause?: Error) {
    super('This Collection Authority Record Already Exists.', program, cause);
  }
}
codeToErrorMap.set(0x57, CollectionAuthorityRecordAlreadyExistsError);
nameToErrorMap.set(
  'CollectionAuthorityRecordAlreadyExists',
  CollectionAuthorityRecordAlreadyExistsError
);

/** CollectionAuthorityDoesNotExist: This Collection Authority Record Does Not Exist. */
export class CollectionAuthorityDoesNotExistError extends ProgramError {
  readonly name: string = 'CollectionAuthorityDoesNotExist';

  readonly code: number = 0x58; // 88

  constructor(program: Program, cause?: Error) {
    super('This Collection Authority Record Does Not Exist.', program, cause);
  }
}
codeToErrorMap.set(0x58, CollectionAuthorityDoesNotExistError);
nameToErrorMap.set(
  'CollectionAuthorityDoesNotExist',
  CollectionAuthorityDoesNotExistError
);

/** InvalidUseAuthorityRecord: This Use Authority Record is invalid. */
export class InvalidUseAuthorityRecordError extends ProgramError {
  readonly name: string = 'InvalidUseAuthorityRecord';

  readonly code: number = 0x59; // 89

  constructor(program: Program, cause?: Error) {
    super('This Use Authority Record is invalid.', program, cause);
  }
}
codeToErrorMap.set(0x59, InvalidUseAuthorityRecordError);
nameToErrorMap.set('InvalidUseAuthorityRecord', InvalidUseAuthorityRecordError);

/** InvalidCollectionAuthorityRecord */
export class InvalidCollectionAuthorityRecordError extends ProgramError {
  readonly name: string = 'InvalidCollectionAuthorityRecord';

  readonly code: number = 0x5a; // 90

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x5a, InvalidCollectionAuthorityRecordError);
nameToErrorMap.set(
  'InvalidCollectionAuthorityRecord',
  InvalidCollectionAuthorityRecordError
);

/** InvalidFreezeAuthority: Metadata does not match the freeze authority on the mint */
export class InvalidFreezeAuthorityError extends ProgramError {
  readonly name: string = 'InvalidFreezeAuthority';

  readonly code: number = 0x5b; // 91

  constructor(program: Program, cause?: Error) {
    super(
      'Metadata does not match the freeze authority on the mint',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x5b, InvalidFreezeAuthorityError);
nameToErrorMap.set('InvalidFreezeAuthority', InvalidFreezeAuthorityError);

/** InvalidDelegate: All tokens in this account have not been delegated to this user. */
export class InvalidDelegateError extends ProgramError {
  readonly name: string = 'InvalidDelegate';

  readonly code: number = 0x5c; // 92

  constructor(program: Program, cause?: Error) {
    super(
      'All tokens in this account have not been delegated to this user.',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x5c, InvalidDelegateError);
nameToErrorMap.set('InvalidDelegate', InvalidDelegateError);

/** CannotAdjustVerifiedCreator */
export class CannotAdjustVerifiedCreatorError extends ProgramError {
  readonly name: string = 'CannotAdjustVerifiedCreator';

  readonly code: number = 0x5d; // 93

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x5d, CannotAdjustVerifiedCreatorError);
nameToErrorMap.set(
  'CannotAdjustVerifiedCreator',
  CannotAdjustVerifiedCreatorError
);

/** CannotRemoveVerifiedCreator: Verified creators cannot be removed. */
export class CannotRemoveVerifiedCreatorError extends ProgramError {
  readonly name: string = 'CannotRemoveVerifiedCreator';

  readonly code: number = 0x5e; // 94

  constructor(program: Program, cause?: Error) {
    super('Verified creators cannot be removed.', program, cause);
  }
}
codeToErrorMap.set(0x5e, CannotRemoveVerifiedCreatorError);
nameToErrorMap.set(
  'CannotRemoveVerifiedCreator',
  CannotRemoveVerifiedCreatorError
);

/** CannotWipeVerifiedCreators */
export class CannotWipeVerifiedCreatorsError extends ProgramError {
  readonly name: string = 'CannotWipeVerifiedCreators';

  readonly code: number = 0x5f; // 95

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x5f, CannotWipeVerifiedCreatorsError);
nameToErrorMap.set(
  'CannotWipeVerifiedCreators',
  CannotWipeVerifiedCreatorsError
);

/** NotAllowedToChangeSellerFeeBasisPoints */
export class NotAllowedToChangeSellerFeeBasisPointsError extends ProgramError {
  readonly name: string = 'NotAllowedToChangeSellerFeeBasisPoints';

  readonly code: number = 0x60; // 96

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x60, NotAllowedToChangeSellerFeeBasisPointsError);
nameToErrorMap.set(
  'NotAllowedToChangeSellerFeeBasisPoints',
  NotAllowedToChangeSellerFeeBasisPointsError
);

/** EditionOverrideCannotBeZero: Edition override cannot be zero */
export class EditionOverrideCannotBeZeroError extends ProgramError {
  readonly name: string = 'EditionOverrideCannotBeZero';

  readonly code: number = 0x61; // 97

  constructor(program: Program, cause?: Error) {
    super('Edition override cannot be zero', program, cause);
  }
}
codeToErrorMap.set(0x61, EditionOverrideCannotBeZeroError);
nameToErrorMap.set(
  'EditionOverrideCannotBeZero',
  EditionOverrideCannotBeZeroError
);

/** InvalidUser: Invalid User */
export class InvalidUserError extends ProgramError {
  readonly name: string = 'InvalidUser';

  readonly code: number = 0x62; // 98

  constructor(program: Program, cause?: Error) {
    super('Invalid User', program, cause);
  }
}
codeToErrorMap.set(0x62, InvalidUserError);
nameToErrorMap.set('InvalidUser', InvalidUserError);

/** RevokeCollectionAuthoritySignerIncorrect: Revoke Collection Authority signer is incorrect */
export class RevokeCollectionAuthoritySignerIncorrectError extends ProgramError {
  readonly name: string = 'RevokeCollectionAuthoritySignerIncorrect';

  readonly code: number = 0x63; // 99

  constructor(program: Program, cause?: Error) {
    super('Revoke Collection Authority signer is incorrect', program, cause);
  }
}
codeToErrorMap.set(0x63, RevokeCollectionAuthoritySignerIncorrectError);
nameToErrorMap.set(
  'RevokeCollectionAuthoritySignerIncorrect',
  RevokeCollectionAuthoritySignerIncorrectError
);

/** TokenCloseFailed */
export class TokenCloseFailedError extends ProgramError {
  readonly name: string = 'TokenCloseFailed';

  readonly code: number = 0x64; // 100

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x64, TokenCloseFailedError);
nameToErrorMap.set('TokenCloseFailed', TokenCloseFailedError);

/** UnsizedCollection: Can't use this function on unsized collection */
export class UnsizedCollectionError extends ProgramError {
  readonly name: string = 'UnsizedCollection';

  readonly code: number = 0x65; // 101

  constructor(program: Program, cause?: Error) {
    super("Can't use this function on unsized collection", program, cause);
  }
}
codeToErrorMap.set(0x65, UnsizedCollectionError);
nameToErrorMap.set('UnsizedCollection', UnsizedCollectionError);

/** SizedCollection: Can't use this function on a sized collection */
export class SizedCollectionError extends ProgramError {
  readonly name: string = 'SizedCollection';

  readonly code: number = 0x66; // 102

  constructor(program: Program, cause?: Error) {
    super("Can't use this function on a sized collection", program, cause);
  }
}
codeToErrorMap.set(0x66, SizedCollectionError);
nameToErrorMap.set('SizedCollection', SizedCollectionError);

/** MissingCollectionMetadata: Missing collection metadata account */
export class MissingCollectionMetadataError extends ProgramError {
  readonly name: string = 'MissingCollectionMetadata';

  readonly code: number = 0x67; // 103

  constructor(program: Program, cause?: Error) {
    super('Missing collection metadata account', program, cause);
  }
}
codeToErrorMap.set(0x67, MissingCollectionMetadataError);
nameToErrorMap.set('MissingCollectionMetadata', MissingCollectionMetadataError);

/** NotAMemberOfCollection: This NFT is not a member of the specified collection. */
export class NotAMemberOfCollectionError extends ProgramError {
  readonly name: string = 'NotAMemberOfCollection';

  readonly code: number = 0x68; // 104

  constructor(program: Program, cause?: Error) {
    super(
      'This NFT is not a member of the specified collection.',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x68, NotAMemberOfCollectionError);
nameToErrorMap.set('NotAMemberOfCollection', NotAMemberOfCollectionError);

/** NotVerifiedMemberOfCollection: This NFT is not a verified member of the specified collection. */
export class NotVerifiedMemberOfCollectionError extends ProgramError {
  readonly name: string = 'NotVerifiedMemberOfCollection';

  readonly code: number = 0x69; // 105

  constructor(program: Program, cause?: Error) {
    super(
      'This NFT is not a verified member of the specified collection.',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x69, NotVerifiedMemberOfCollectionError);
nameToErrorMap.set(
  'NotVerifiedMemberOfCollection',
  NotVerifiedMemberOfCollectionError
);

/** NotACollectionParent: This NFT is not a collection parent NFT. */
export class NotACollectionParentError extends ProgramError {
  readonly name: string = 'NotACollectionParent';

  readonly code: number = 0x6a; // 106

  constructor(program: Program, cause?: Error) {
    super('This NFT is not a collection parent NFT.', program, cause);
  }
}
codeToErrorMap.set(0x6a, NotACollectionParentError);
nameToErrorMap.set('NotACollectionParent', NotACollectionParentError);

/** CouldNotDetermineTokenStandard: Could not determine a TokenStandard type. */
export class CouldNotDetermineTokenStandardError extends ProgramError {
  readonly name: string = 'CouldNotDetermineTokenStandard';

  readonly code: number = 0x6b; // 107

  constructor(program: Program, cause?: Error) {
    super('Could not determine a TokenStandard type.', program, cause);
  }
}
codeToErrorMap.set(0x6b, CouldNotDetermineTokenStandardError);
nameToErrorMap.set(
  'CouldNotDetermineTokenStandard',
  CouldNotDetermineTokenStandardError
);

/** MissingEditionAccount: This mint account has an edition but none was provided. */
export class MissingEditionAccountError extends ProgramError {
  readonly name: string = 'MissingEditionAccount';

  readonly code: number = 0x6c; // 108

  constructor(program: Program, cause?: Error) {
    super(
      'This mint account has an edition but none was provided.',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x6c, MissingEditionAccountError);
nameToErrorMap.set('MissingEditionAccount', MissingEditionAccountError);

/** NotAMasterEdition: This edition is not a Master Edition */
export class NotAMasterEditionError extends ProgramError {
  readonly name: string = 'NotAMasterEdition';

  readonly code: number = 0x6d; // 109

  constructor(program: Program, cause?: Error) {
    super('This edition is not a Master Edition', program, cause);
  }
}
codeToErrorMap.set(0x6d, NotAMasterEditionError);
nameToErrorMap.set('NotAMasterEdition', NotAMasterEditionError);

/** MasterEditionHasPrints: This Master Edition has existing prints */
export class MasterEditionHasPrintsError extends ProgramError {
  readonly name: string = 'MasterEditionHasPrints';

  readonly code: number = 0x6e; // 110

  constructor(program: Program, cause?: Error) {
    super('This Master Edition has existing prints', program, cause);
  }
}
codeToErrorMap.set(0x6e, MasterEditionHasPrintsError);
nameToErrorMap.set('MasterEditionHasPrints', MasterEditionHasPrintsError);

/** BorshDeserializationError */
export class BorshDeserializationErrorError extends ProgramError {
  readonly name: string = 'BorshDeserializationError';

  readonly code: number = 0x6f; // 111

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x6f, BorshDeserializationErrorError);
nameToErrorMap.set('BorshDeserializationError', BorshDeserializationErrorError);

/** CannotUpdateVerifiedCollection: Cannot update a verified collection in this command */
export class CannotUpdateVerifiedCollectionError extends ProgramError {
  readonly name: string = 'CannotUpdateVerifiedCollection';

  readonly code: number = 0x70; // 112

  constructor(program: Program, cause?: Error) {
    super(
      'Cannot update a verified collection in this command',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x70, CannotUpdateVerifiedCollectionError);
nameToErrorMap.set(
  'CannotUpdateVerifiedCollection',
  CannotUpdateVerifiedCollectionError
);

/** CollectionMasterEditionAccountInvalid: Edition account doesnt match collection  */
export class CollectionMasterEditionAccountInvalidError extends ProgramError {
  readonly name: string = 'CollectionMasterEditionAccountInvalid';

  readonly code: number = 0x71; // 113

  constructor(program: Program, cause?: Error) {
    super('Edition account doesnt match collection ', program, cause);
  }
}
codeToErrorMap.set(0x71, CollectionMasterEditionAccountInvalidError);
nameToErrorMap.set(
  'CollectionMasterEditionAccountInvalid',
  CollectionMasterEditionAccountInvalidError
);

/** AlreadyVerified: Item is already verified. */
export class AlreadyVerifiedError extends ProgramError {
  readonly name: string = 'AlreadyVerified';

  readonly code: number = 0x72; // 114

  constructor(program: Program, cause?: Error) {
    super('Item is already verified.', program, cause);
  }
}
codeToErrorMap.set(0x72, AlreadyVerifiedError);
nameToErrorMap.set('AlreadyVerified', AlreadyVerifiedError);

/** AlreadyUnverified */
export class AlreadyUnverifiedError extends ProgramError {
  readonly name: string = 'AlreadyUnverified';

  readonly code: number = 0x73; // 115

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0x73, AlreadyUnverifiedError);
nameToErrorMap.set('AlreadyUnverified', AlreadyUnverifiedError);

/** NotAPrintEdition: This edition is not a Print Edition */
export class NotAPrintEditionError extends ProgramError {
  readonly name: string = 'NotAPrintEdition';

  readonly code: number = 0x74; // 116

  constructor(program: Program, cause?: Error) {
    super('This edition is not a Print Edition', program, cause);
  }
}
codeToErrorMap.set(0x74, NotAPrintEditionError);
nameToErrorMap.set('NotAPrintEdition', NotAPrintEditionError);

/** InvalidMasterEdition: Invalid Master Edition */
export class InvalidMasterEditionError extends ProgramError {
  readonly name: string = 'InvalidMasterEdition';

  readonly code: number = 0x75; // 117

  constructor(program: Program, cause?: Error) {
    super('Invalid Master Edition', program, cause);
  }
}
codeToErrorMap.set(0x75, InvalidMasterEditionError);
nameToErrorMap.set('InvalidMasterEdition', InvalidMasterEditionError);

/** InvalidPrintEdition: Invalid Print Edition */
export class InvalidPrintEditionError extends ProgramError {
  readonly name: string = 'InvalidPrintEdition';

  readonly code: number = 0x76; // 118

  constructor(program: Program, cause?: Error) {
    super('Invalid Print Edition', program, cause);
  }
}
codeToErrorMap.set(0x76, InvalidPrintEditionError);
nameToErrorMap.set('InvalidPrintEdition', InvalidPrintEditionError);

/** InvalidEditionMarker: Invalid Edition Marker */
export class InvalidEditionMarkerError extends ProgramError {
  readonly name: string = 'InvalidEditionMarker';

  readonly code: number = 0x77; // 119

  constructor(program: Program, cause?: Error) {
    super('Invalid Edition Marker', program, cause);
  }
}
codeToErrorMap.set(0x77, InvalidEditionMarkerError);
nameToErrorMap.set('InvalidEditionMarker', InvalidEditionMarkerError);

/** ReservationListDeprecated: Reservation List is Deprecated */
export class ReservationListDeprecatedError extends ProgramError {
  readonly name: string = 'ReservationListDeprecated';

  readonly code: number = 0x78; // 120

  constructor(program: Program, cause?: Error) {
    super('Reservation List is Deprecated', program, cause);
  }
}
codeToErrorMap.set(0x78, ReservationListDeprecatedError);
nameToErrorMap.set('ReservationListDeprecated', ReservationListDeprecatedError);

/** PrintEditionDoesNotMatchMasterEdition: Print Edition does not match Master Edition */
export class PrintEditionDoesNotMatchMasterEditionError extends ProgramError {
  readonly name: string = 'PrintEditionDoesNotMatchMasterEdition';

  readonly code: number = 0x79; // 121

  constructor(program: Program, cause?: Error) {
    super('Print Edition does not match Master Edition', program, cause);
  }
}
codeToErrorMap.set(0x79, PrintEditionDoesNotMatchMasterEditionError);
nameToErrorMap.set(
  'PrintEditionDoesNotMatchMasterEdition',
  PrintEditionDoesNotMatchMasterEditionError
);

/** EditionNumberGreaterThanMaxSupply: Edition Number greater than max supply */
export class EditionNumberGreaterThanMaxSupplyError extends ProgramError {
  readonly name: string = 'EditionNumberGreaterThanMaxSupply';

  readonly code: number = 0x7a; // 122

  constructor(program: Program, cause?: Error) {
    super('Edition Number greater than max supply', program, cause);
  }
}
codeToErrorMap.set(0x7a, EditionNumberGreaterThanMaxSupplyError);
nameToErrorMap.set(
  'EditionNumberGreaterThanMaxSupply',
  EditionNumberGreaterThanMaxSupplyError
);

/** MustUnverify: Must unverify before migrating collections. */
export class MustUnverifyError extends ProgramError {
  readonly name: string = 'MustUnverify';

  readonly code: number = 0x7b; // 123

  constructor(program: Program, cause?: Error) {
    super('Must unverify before migrating collections.', program, cause);
  }
}
codeToErrorMap.set(0x7b, MustUnverifyError);
nameToErrorMap.set('MustUnverify', MustUnverifyError);

/** InvalidEscrowBumpSeed: Invalid Escrow Account Bump Seed */
export class InvalidEscrowBumpSeedError extends ProgramError {
  readonly name: string = 'InvalidEscrowBumpSeed';

  readonly code: number = 0x7c; // 124

  constructor(program: Program, cause?: Error) {
    super('Invalid Escrow Account Bump Seed', program, cause);
  }
}
codeToErrorMap.set(0x7c, InvalidEscrowBumpSeedError);
nameToErrorMap.set('InvalidEscrowBumpSeed', InvalidEscrowBumpSeedError);

/** MustBeEscrowAuthority: Must Escrow Authority */
export class MustBeEscrowAuthorityError extends ProgramError {
  readonly name: string = 'MustBeEscrowAuthority';

  readonly code: number = 0x7d; // 125

  constructor(program: Program, cause?: Error) {
    super('Must Escrow Authority', program, cause);
  }
}
codeToErrorMap.set(0x7d, MustBeEscrowAuthorityError);
nameToErrorMap.set('MustBeEscrowAuthority', MustBeEscrowAuthorityError);

/** InvalidSystemProgram: Invalid System Program */
export class InvalidSystemProgramError extends ProgramError {
  readonly name: string = 'InvalidSystemProgram';

  readonly code: number = 0x7e; // 126

  constructor(program: Program, cause?: Error) {
    super('Invalid System Program', program, cause);
  }
}
codeToErrorMap.set(0x7e, InvalidSystemProgramError);
nameToErrorMap.set('InvalidSystemProgram', InvalidSystemProgramError);

/** MustBeNonFungible: Must be a Non Fungible Token */
export class MustBeNonFungibleError extends ProgramError {
  readonly name: string = 'MustBeNonFungible';

  readonly code: number = 0x7f; // 127

  constructor(program: Program, cause?: Error) {
    super('Must be a Non Fungible Token', program, cause);
  }
}
codeToErrorMap.set(0x7f, MustBeNonFungibleError);
nameToErrorMap.set('MustBeNonFungible', MustBeNonFungibleError);

/** InsufficientTokens: Insufficient tokens for transfer */
export class InsufficientTokensError extends ProgramError {
  readonly name: string = 'InsufficientTokens';

  readonly code: number = 0x80; // 128

  constructor(program: Program, cause?: Error) {
    super('Insufficient tokens for transfer', program, cause);
  }
}
codeToErrorMap.set(0x80, InsufficientTokensError);
nameToErrorMap.set('InsufficientTokens', InsufficientTokensError);

/** BorshSerializationError: Borsh Serialization Error */
export class BorshSerializationErrorError extends ProgramError {
  readonly name: string = 'BorshSerializationError';

  readonly code: number = 0x81; // 129

  constructor(program: Program, cause?: Error) {
    super('Borsh Serialization Error', program, cause);
  }
}
codeToErrorMap.set(0x81, BorshSerializationErrorError);
nameToErrorMap.set('BorshSerializationError', BorshSerializationErrorError);

/** NoFreezeAuthoritySet: Cannot create NFT with no Freeze Authority. */
export class NoFreezeAuthoritySetError extends ProgramError {
  readonly name: string = 'NoFreezeAuthoritySet';

  readonly code: number = 0x82; // 130

  constructor(program: Program, cause?: Error) {
    super('Cannot create NFT with no Freeze Authority.', program, cause);
  }
}
codeToErrorMap.set(0x82, NoFreezeAuthoritySetError);
nameToErrorMap.set('NoFreezeAuthoritySet', NoFreezeAuthoritySetError);

/** InvalidCollectionSizeChange: Invalid collection size change */
export class InvalidCollectionSizeChangeError extends ProgramError {
  readonly name: string = 'InvalidCollectionSizeChange';

  readonly code: number = 0x83; // 131

  constructor(program: Program, cause?: Error) {
    super('Invalid collection size change', program, cause);
  }
}
codeToErrorMap.set(0x83, InvalidCollectionSizeChangeError);
nameToErrorMap.set(
  'InvalidCollectionSizeChange',
  InvalidCollectionSizeChangeError
);

/** InvalidBubblegumSigner: Invalid bubblegum signer */
export class InvalidBubblegumSignerError extends ProgramError {
  readonly name: string = 'InvalidBubblegumSigner';

  readonly code: number = 0x84; // 132

  constructor(program: Program, cause?: Error) {
    super('Invalid bubblegum signer', program, cause);
  }
}
codeToErrorMap.set(0x84, InvalidBubblegumSignerError);
nameToErrorMap.set('InvalidBubblegumSigner', InvalidBubblegumSignerError);

/** EscrowParentHasDelegate: Escrow parent cannot have a delegate */
export class EscrowParentHasDelegateError extends ProgramError {
  readonly name: string = 'EscrowParentHasDelegate';

  readonly code: number = 0x85; // 133

  constructor(program: Program, cause?: Error) {
    super('Escrow parent cannot have a delegate', program, cause);
  }
}
codeToErrorMap.set(0x85, EscrowParentHasDelegateError);
nameToErrorMap.set('EscrowParentHasDelegate', EscrowParentHasDelegateError);

/** MintIsNotSigner: Mint needs to be signer to initialize the account */
export class MintIsNotSignerError extends ProgramError {
  readonly name: string = 'MintIsNotSigner';

  readonly code: number = 0x86; // 134

  constructor(program: Program, cause?: Error) {
    super('Mint needs to be signer to initialize the account', program, cause);
  }
}
codeToErrorMap.set(0x86, MintIsNotSignerError);
nameToErrorMap.set('MintIsNotSigner', MintIsNotSignerError);

/** InvalidTokenStandard: Invalid token standard */
export class InvalidTokenStandardError extends ProgramError {
  readonly name: string = 'InvalidTokenStandard';

  readonly code: number = 0x87; // 135

  constructor(program: Program, cause?: Error) {
    super('Invalid token standard', program, cause);
  }
}
codeToErrorMap.set(0x87, InvalidTokenStandardError);
nameToErrorMap.set('InvalidTokenStandard', InvalidTokenStandardError);

/** InvalidMintForTokenStandard: Invalid mint account for specified token standard */
export class InvalidMintForTokenStandardError extends ProgramError {
  readonly name: string = 'InvalidMintForTokenStandard';

  readonly code: number = 0x88; // 136

  constructor(program: Program, cause?: Error) {
    super('Invalid mint account for specified token standard', program, cause);
  }
}
codeToErrorMap.set(0x88, InvalidMintForTokenStandardError);
nameToErrorMap.set(
  'InvalidMintForTokenStandard',
  InvalidMintForTokenStandardError
);

/** InvalidAuthorizationRules: Invalid authorization rules account */
export class InvalidAuthorizationRulesError extends ProgramError {
  readonly name: string = 'InvalidAuthorizationRules';

  readonly code: number = 0x89; // 137

  constructor(program: Program, cause?: Error) {
    super('Invalid authorization rules account', program, cause);
  }
}
codeToErrorMap.set(0x89, InvalidAuthorizationRulesError);
nameToErrorMap.set('InvalidAuthorizationRules', InvalidAuthorizationRulesError);

/** MissingAuthorizationRules: Missing authorization rules account */
export class MissingAuthorizationRulesError extends ProgramError {
  readonly name: string = 'MissingAuthorizationRules';

  readonly code: number = 0x8a; // 138

  constructor(program: Program, cause?: Error) {
    super('Missing authorization rules account', program, cause);
  }
}
codeToErrorMap.set(0x8a, MissingAuthorizationRulesError);
nameToErrorMap.set('MissingAuthorizationRules', MissingAuthorizationRulesError);

/** MissingProgrammableConfig: Missing programmable configuration */
export class MissingProgrammableConfigError extends ProgramError {
  readonly name: string = 'MissingProgrammableConfig';

  readonly code: number = 0x8b; // 139

  constructor(program: Program, cause?: Error) {
    super('Missing programmable configuration', program, cause);
  }
}
codeToErrorMap.set(0x8b, MissingProgrammableConfigError);
nameToErrorMap.set('MissingProgrammableConfig', MissingProgrammableConfigError);

/** InvalidProgrammableConfig: Invalid programmable configuration */
export class InvalidProgrammableConfigError extends ProgramError {
  readonly name: string = 'InvalidProgrammableConfig';

  readonly code: number = 0x8c; // 140

  constructor(program: Program, cause?: Error) {
    super('Invalid programmable configuration', program, cause);
  }
}
codeToErrorMap.set(0x8c, InvalidProgrammableConfigError);
nameToErrorMap.set('InvalidProgrammableConfig', InvalidProgrammableConfigError);

/** DelegateAlreadyExists: Delegate already exists */
export class DelegateAlreadyExistsError extends ProgramError {
  readonly name: string = 'DelegateAlreadyExists';

  readonly code: number = 0x8d; // 141

  constructor(program: Program, cause?: Error) {
    super('Delegate already exists', program, cause);
  }
}
codeToErrorMap.set(0x8d, DelegateAlreadyExistsError);
nameToErrorMap.set('DelegateAlreadyExists', DelegateAlreadyExistsError);

/** DelegateNotFound: Delegate not found */
export class DelegateNotFoundError extends ProgramError {
  readonly name: string = 'DelegateNotFound';

  readonly code: number = 0x8e; // 142

  constructor(program: Program, cause?: Error) {
    super('Delegate not found', program, cause);
  }
}
codeToErrorMap.set(0x8e, DelegateNotFoundError);
nameToErrorMap.set('DelegateNotFound', DelegateNotFoundError);

/** MissingAccountInBuilder: Required account not set in instruction builder */
export class MissingAccountInBuilderError extends ProgramError {
  readonly name: string = 'MissingAccountInBuilder';

  readonly code: number = 0x8f; // 143

  constructor(program: Program, cause?: Error) {
    super('Required account not set in instruction builder', program, cause);
  }
}
codeToErrorMap.set(0x8f, MissingAccountInBuilderError);
nameToErrorMap.set('MissingAccountInBuilder', MissingAccountInBuilderError);

/** MissingArgumentInBuilder: Required argument not set in instruction builder */
export class MissingArgumentInBuilderError extends ProgramError {
  readonly name: string = 'MissingArgumentInBuilder';

  readonly code: number = 0x90; // 144

  constructor(program: Program, cause?: Error) {
    super('Required argument not set in instruction builder', program, cause);
  }
}
codeToErrorMap.set(0x90, MissingArgumentInBuilderError);
nameToErrorMap.set('MissingArgumentInBuilder', MissingArgumentInBuilderError);

/** FeatureNotSupported: Feature not supported currently */
export class FeatureNotSupportedError extends ProgramError {
  readonly name: string = 'FeatureNotSupported';

  readonly code: number = 0x91; // 145

  constructor(program: Program, cause?: Error) {
    super('Feature not supported currently', program, cause);
  }
}
codeToErrorMap.set(0x91, FeatureNotSupportedError);
nameToErrorMap.set('FeatureNotSupported', FeatureNotSupportedError);

/** InvalidSystemWallet: Invalid system wallet */
export class InvalidSystemWalletError extends ProgramError {
  readonly name: string = 'InvalidSystemWallet';

  readonly code: number = 0x92; // 146

  constructor(program: Program, cause?: Error) {
    super('Invalid system wallet', program, cause);
  }
}
codeToErrorMap.set(0x92, InvalidSystemWalletError);
nameToErrorMap.set('InvalidSystemWallet', InvalidSystemWalletError);

/** OnlySaleDelegateCanTransfer: Only the sale delegate can transfer while its set */
export class OnlySaleDelegateCanTransferError extends ProgramError {
  readonly name: string = 'OnlySaleDelegateCanTransfer';

  readonly code: number = 0x93; // 147

  constructor(program: Program, cause?: Error) {
    super('Only the sale delegate can transfer while its set', program, cause);
  }
}
codeToErrorMap.set(0x93, OnlySaleDelegateCanTransferError);
nameToErrorMap.set(
  'OnlySaleDelegateCanTransfer',
  OnlySaleDelegateCanTransferError
);

/** MissingTokenAccount: Missing token account */
export class MissingTokenAccountError extends ProgramError {
  readonly name: string = 'MissingTokenAccount';

  readonly code: number = 0x94; // 148

  constructor(program: Program, cause?: Error) {
    super('Missing token account', program, cause);
  }
}
codeToErrorMap.set(0x94, MissingTokenAccountError);
nameToErrorMap.set('MissingTokenAccount', MissingTokenAccountError);

/** MissingSplTokenProgram: Missing SPL token program */
export class MissingSplTokenProgramError extends ProgramError {
  readonly name: string = 'MissingSplTokenProgram';

  readonly code: number = 0x95; // 149

  constructor(program: Program, cause?: Error) {
    super('Missing SPL token program', program, cause);
  }
}
codeToErrorMap.set(0x95, MissingSplTokenProgramError);
nameToErrorMap.set('MissingSplTokenProgram', MissingSplTokenProgramError);

/** MissingAuthorizationRulesProgram: Missing authorization rules program */
export class MissingAuthorizationRulesProgramError extends ProgramError {
  readonly name: string = 'MissingAuthorizationRulesProgram';

  readonly code: number = 0x96; // 150

  constructor(program: Program, cause?: Error) {
    super('Missing authorization rules program', program, cause);
  }
}
codeToErrorMap.set(0x96, MissingAuthorizationRulesProgramError);
nameToErrorMap.set(
  'MissingAuthorizationRulesProgram',
  MissingAuthorizationRulesProgramError
);

/** InvalidDelegateRoleForTransfer: Invalid delegate role for transfer */
export class InvalidDelegateRoleForTransferError extends ProgramError {
  readonly name: string = 'InvalidDelegateRoleForTransfer';

  readonly code: number = 0x97; // 151

  constructor(program: Program, cause?: Error) {
    super('Invalid delegate role for transfer', program, cause);
  }
}
codeToErrorMap.set(0x97, InvalidDelegateRoleForTransferError);
nameToErrorMap.set(
  'InvalidDelegateRoleForTransfer',
  InvalidDelegateRoleForTransferError
);

/** InvalidTransferAuthority: Invalid transfer authority */
export class InvalidTransferAuthorityError extends ProgramError {
  readonly name: string = 'InvalidTransferAuthority';

  readonly code: number = 0x98; // 152

  constructor(program: Program, cause?: Error) {
    super('Invalid transfer authority', program, cause);
  }
}
codeToErrorMap.set(0x98, InvalidTransferAuthorityError);
nameToErrorMap.set('InvalidTransferAuthority', InvalidTransferAuthorityError);

/** InstructionNotSupported: Instruction not supported for ProgrammableNonFungible assets */
export class InstructionNotSupportedError extends ProgramError {
  readonly name: string = 'InstructionNotSupported';

  readonly code: number = 0x99; // 153

  constructor(program: Program, cause?: Error) {
    super(
      'Instruction not supported for ProgrammableNonFungible assets',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0x99, InstructionNotSupportedError);
nameToErrorMap.set('InstructionNotSupported', InstructionNotSupportedError);

/** KeyMismatch: Public key does not match expected value */
export class KeyMismatchError extends ProgramError {
  readonly name: string = 'KeyMismatch';

  readonly code: number = 0x9a; // 154

  constructor(program: Program, cause?: Error) {
    super('Public key does not match expected value', program, cause);
  }
}
codeToErrorMap.set(0x9a, KeyMismatchError);
nameToErrorMap.set('KeyMismatch', KeyMismatchError);

/** LockedToken: Token is locked */
export class LockedTokenError extends ProgramError {
  readonly name: string = 'LockedToken';

  readonly code: number = 0x9b; // 155

  constructor(program: Program, cause?: Error) {
    super('Token is locked', program, cause);
  }
}
codeToErrorMap.set(0x9b, LockedTokenError);
nameToErrorMap.set('LockedToken', LockedTokenError);

/** UnlockedToken: Token is unlocked */
export class UnlockedTokenError extends ProgramError {
  readonly name: string = 'UnlockedToken';

  readonly code: number = 0x9c; // 156

  constructor(program: Program, cause?: Error) {
    super('Token is unlocked', program, cause);
  }
}
codeToErrorMap.set(0x9c, UnlockedTokenError);
nameToErrorMap.set('UnlockedToken', UnlockedTokenError);

/** MissingDelegateRole: Missing delegate role */
export class MissingDelegateRoleError extends ProgramError {
  readonly name: string = 'MissingDelegateRole';

  readonly code: number = 0x9d; // 157

  constructor(program: Program, cause?: Error) {
    super('Missing delegate role', program, cause);
  }
}
codeToErrorMap.set(0x9d, MissingDelegateRoleError);
nameToErrorMap.set('MissingDelegateRole', MissingDelegateRoleError);

/** InvalidAuthorityType: Invalid authority type */
export class InvalidAuthorityTypeError extends ProgramError {
  readonly name: string = 'InvalidAuthorityType';

  readonly code: number = 0x9e; // 158

  constructor(program: Program, cause?: Error) {
    super('Invalid authority type', program, cause);
  }
}
codeToErrorMap.set(0x9e, InvalidAuthorityTypeError);
nameToErrorMap.set('InvalidAuthorityType', InvalidAuthorityTypeError);

/** MissingTokenRecord: Missing token record account */
export class MissingTokenRecordError extends ProgramError {
  readonly name: string = 'MissingTokenRecord';

  readonly code: number = 0x9f; // 159

  constructor(program: Program, cause?: Error) {
    super('Missing token record account', program, cause);
  }
}
codeToErrorMap.set(0x9f, MissingTokenRecordError);
nameToErrorMap.set('MissingTokenRecord', MissingTokenRecordError);

/** MintSupplyMustBeZero: Mint supply must be zero for programmable assets */
export class MintSupplyMustBeZeroError extends ProgramError {
  readonly name: string = 'MintSupplyMustBeZero';

  readonly code: number = 0xa0; // 160

  constructor(program: Program, cause?: Error) {
    super('Mint supply must be zero for programmable assets', program, cause);
  }
}
codeToErrorMap.set(0xa0, MintSupplyMustBeZeroError);
nameToErrorMap.set('MintSupplyMustBeZero', MintSupplyMustBeZeroError);

/** DataIsEmptyOrZeroed: Data is empty or zeroed */
export class DataIsEmptyOrZeroedError extends ProgramError {
  readonly name: string = 'DataIsEmptyOrZeroed';

  readonly code: number = 0xa1; // 161

  constructor(program: Program, cause?: Error) {
    super('Data is empty or zeroed', program, cause);
  }
}
codeToErrorMap.set(0xa1, DataIsEmptyOrZeroedError);
nameToErrorMap.set('DataIsEmptyOrZeroed', DataIsEmptyOrZeroedError);

/** MissingTokenOwnerAccount: Missing token owner */
export class MissingTokenOwnerAccountError extends ProgramError {
  readonly name: string = 'MissingTokenOwnerAccount';

  readonly code: number = 0xa2; // 162

  constructor(program: Program, cause?: Error) {
    super('Missing token owner', program, cause);
  }
}
codeToErrorMap.set(0xa2, MissingTokenOwnerAccountError);
nameToErrorMap.set('MissingTokenOwnerAccount', MissingTokenOwnerAccountError);

/** InvalidMasterEditionAccountLength: Master edition account has an invalid length */
export class InvalidMasterEditionAccountLengthError extends ProgramError {
  readonly name: string = 'InvalidMasterEditionAccountLength';

  readonly code: number = 0xa3; // 163

  constructor(program: Program, cause?: Error) {
    super('Master edition account has an invalid length', program, cause);
  }
}
codeToErrorMap.set(0xa3, InvalidMasterEditionAccountLengthError);
nameToErrorMap.set(
  'InvalidMasterEditionAccountLength',
  InvalidMasterEditionAccountLengthError
);

/** IncorrectTokenState: Incorrect token state */
export class IncorrectTokenStateError extends ProgramError {
  readonly name: string = 'IncorrectTokenState';

  readonly code: number = 0xa4; // 164

  constructor(program: Program, cause?: Error) {
    super('Incorrect token state', program, cause);
  }
}
codeToErrorMap.set(0xa4, IncorrectTokenStateError);
nameToErrorMap.set('IncorrectTokenState', IncorrectTokenStateError);

/** InvalidDelegateRole: Invalid delegate role */
export class InvalidDelegateRoleError extends ProgramError {
  readonly name: string = 'InvalidDelegateRole';

  readonly code: number = 0xa5; // 165

  constructor(program: Program, cause?: Error) {
    super('Invalid delegate role', program, cause);
  }
}
codeToErrorMap.set(0xa5, InvalidDelegateRoleError);
nameToErrorMap.set('InvalidDelegateRole', InvalidDelegateRoleError);

/** MissingPrintSupply: Print supply is required for non-fungibles */
export class MissingPrintSupplyError extends ProgramError {
  readonly name: string = 'MissingPrintSupply';

  readonly code: number = 0xa6; // 166

  constructor(program: Program, cause?: Error) {
    super('Print supply is required for non-fungibles', program, cause);
  }
}
codeToErrorMap.set(0xa6, MissingPrintSupplyError);
nameToErrorMap.set('MissingPrintSupply', MissingPrintSupplyError);

/** MissingMasterEditionAccount: Missing master edition account */
export class MissingMasterEditionAccountError extends ProgramError {
  readonly name: string = 'MissingMasterEditionAccount';

  readonly code: number = 0xa7; // 167

  constructor(program: Program, cause?: Error) {
    super('Missing master edition account', program, cause);
  }
}
codeToErrorMap.set(0xa7, MissingMasterEditionAccountError);
nameToErrorMap.set(
  'MissingMasterEditionAccount',
  MissingMasterEditionAccountError
);

/** AmountMustBeGreaterThanZero: Amount must be greater than zero */
export class AmountMustBeGreaterThanZeroError extends ProgramError {
  readonly name: string = 'AmountMustBeGreaterThanZero';

  readonly code: number = 0xa8; // 168

  constructor(program: Program, cause?: Error) {
    super('Amount must be greater than zero', program, cause);
  }
}
codeToErrorMap.set(0xa8, AmountMustBeGreaterThanZeroError);
nameToErrorMap.set(
  'AmountMustBeGreaterThanZero',
  AmountMustBeGreaterThanZeroError
);

/** InvalidDelegateArgs: Invalid delegate args */
export class InvalidDelegateArgsError extends ProgramError {
  readonly name: string = 'InvalidDelegateArgs';

  readonly code: number = 0xa9; // 169

  constructor(program: Program, cause?: Error) {
    super('Invalid delegate args', program, cause);
  }
}
codeToErrorMap.set(0xa9, InvalidDelegateArgsError);
nameToErrorMap.set('InvalidDelegateArgs', InvalidDelegateArgsError);

/** MissingLockedTransferAddress: Missing address for locked transfer */
export class MissingLockedTransferAddressError extends ProgramError {
  readonly name: string = 'MissingLockedTransferAddress';

  readonly code: number = 0xaa; // 170

  constructor(program: Program, cause?: Error) {
    super('Missing address for locked transfer', program, cause);
  }
}
codeToErrorMap.set(0xaa, MissingLockedTransferAddressError);
nameToErrorMap.set(
  'MissingLockedTransferAddress',
  MissingLockedTransferAddressError
);

/** InvalidLockedTransferAddress: Invalid destination address for locked transfer */
export class InvalidLockedTransferAddressError extends ProgramError {
  readonly name: string = 'InvalidLockedTransferAddress';

  readonly code: number = 0xab; // 171

  constructor(program: Program, cause?: Error) {
    super('Invalid destination address for locked transfer', program, cause);
  }
}
codeToErrorMap.set(0xab, InvalidLockedTransferAddressError);
nameToErrorMap.set(
  'InvalidLockedTransferAddress',
  InvalidLockedTransferAddressError
);

/** DataIncrementLimitExceeded: Exceeded account realloc increase limit */
export class DataIncrementLimitExceededError extends ProgramError {
  readonly name: string = 'DataIncrementLimitExceeded';

  readonly code: number = 0xac; // 172

  constructor(program: Program, cause?: Error) {
    super('Exceeded account realloc increase limit', program, cause);
  }
}
codeToErrorMap.set(0xac, DataIncrementLimitExceededError);
nameToErrorMap.set(
  'DataIncrementLimitExceeded',
  DataIncrementLimitExceededError
);

/** CannotUpdateAssetWithDelegate: Cannot update the rule set of a programmable asset that has a delegate */
export class CannotUpdateAssetWithDelegateError extends ProgramError {
  readonly name: string = 'CannotUpdateAssetWithDelegate';

  readonly code: number = 0xad; // 173

  constructor(program: Program, cause?: Error) {
    super(
      'Cannot update the rule set of a programmable asset that has a delegate',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0xad, CannotUpdateAssetWithDelegateError);
nameToErrorMap.set(
  'CannotUpdateAssetWithDelegate',
  CannotUpdateAssetWithDelegateError
);

/** InvalidAmount: Invalid token amount for this operation or token standard */
export class InvalidAmountError extends ProgramError {
  readonly name: string = 'InvalidAmount';

  readonly code: number = 0xae; // 174

  constructor(program: Program, cause?: Error) {
    super(
      'Invalid token amount for this operation or token standard',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0xae, InvalidAmountError);
nameToErrorMap.set('InvalidAmount', InvalidAmountError);

/** MissingMasterEditionMintAccount: Missing master edition mint account */
export class MissingMasterEditionMintAccountError extends ProgramError {
  readonly name: string = 'MissingMasterEditionMintAccount';

  readonly code: number = 0xaf; // 175

  constructor(program: Program, cause?: Error) {
    super('Missing master edition mint account', program, cause);
  }
}
codeToErrorMap.set(0xaf, MissingMasterEditionMintAccountError);
nameToErrorMap.set(
  'MissingMasterEditionMintAccount',
  MissingMasterEditionMintAccountError
);

/** MissingMasterEditionTokenAccount: Missing master edition token account */
export class MissingMasterEditionTokenAccountError extends ProgramError {
  readonly name: string = 'MissingMasterEditionTokenAccount';

  readonly code: number = 0xb0; // 176

  constructor(program: Program, cause?: Error) {
    super('Missing master edition token account', program, cause);
  }
}
codeToErrorMap.set(0xb0, MissingMasterEditionTokenAccountError);
nameToErrorMap.set(
  'MissingMasterEditionTokenAccount',
  MissingMasterEditionTokenAccountError
);

/** MissingEditionMarkerAccount: Missing edition marker account */
export class MissingEditionMarkerAccountError extends ProgramError {
  readonly name: string = 'MissingEditionMarkerAccount';

  readonly code: number = 0xb1; // 177

  constructor(program: Program, cause?: Error) {
    super('Missing edition marker account', program, cause);
  }
}
codeToErrorMap.set(0xb1, MissingEditionMarkerAccountError);
nameToErrorMap.set(
  'MissingEditionMarkerAccount',
  MissingEditionMarkerAccountError
);

/** CannotBurnWithDelegate: Cannot burn while persistent delegate is set */
export class CannotBurnWithDelegateError extends ProgramError {
  readonly name: string = 'CannotBurnWithDelegate';

  readonly code: number = 0xb2; // 178

  constructor(program: Program, cause?: Error) {
    super('Cannot burn while persistent delegate is set', program, cause);
  }
}
codeToErrorMap.set(0xb2, CannotBurnWithDelegateError);
nameToErrorMap.set('CannotBurnWithDelegate', CannotBurnWithDelegateError);

/** MissingEdition: Missing edition account */
export class MissingEditionError extends ProgramError {
  readonly name: string = 'MissingEdition';

  readonly code: number = 0xb3; // 179

  constructor(program: Program, cause?: Error) {
    super('Missing edition account', program, cause);
  }
}
codeToErrorMap.set(0xb3, MissingEditionError);
nameToErrorMap.set('MissingEdition', MissingEditionError);

/** InvalidAssociatedTokenAccountProgram: Invalid Associated Token Account Program */
export class InvalidAssociatedTokenAccountProgramError extends ProgramError {
  readonly name: string = 'InvalidAssociatedTokenAccountProgram';

  readonly code: number = 0xb4; // 180

  constructor(program: Program, cause?: Error) {
    super('Invalid Associated Token Account Program', program, cause);
  }
}
codeToErrorMap.set(0xb4, InvalidAssociatedTokenAccountProgramError);
nameToErrorMap.set(
  'InvalidAssociatedTokenAccountProgram',
  InvalidAssociatedTokenAccountProgramError
);

/** InvalidInstructionsSysvar: Invalid InstructionsSysvar */
export class InvalidInstructionsSysvarError extends ProgramError {
  readonly name: string = 'InvalidInstructionsSysvar';

  readonly code: number = 0xb5; // 181

  constructor(program: Program, cause?: Error) {
    super('Invalid InstructionsSysvar', program, cause);
  }
}
codeToErrorMap.set(0xb5, InvalidInstructionsSysvarError);
nameToErrorMap.set('InvalidInstructionsSysvar', InvalidInstructionsSysvarError);

/** InvalidParentAccounts: Invalid or Unneeded parent accounts */
export class InvalidParentAccountsError extends ProgramError {
  readonly name: string = 'InvalidParentAccounts';

  readonly code: number = 0xb6; // 182

  constructor(program: Program, cause?: Error) {
    super('Invalid or Unneeded parent accounts', program, cause);
  }
}
codeToErrorMap.set(0xb6, InvalidParentAccountsError);
nameToErrorMap.set('InvalidParentAccounts', InvalidParentAccountsError);

/** InvalidUpdateArgs: Authority cannot apply all update args */
export class InvalidUpdateArgsError extends ProgramError {
  readonly name: string = 'InvalidUpdateArgs';

  readonly code: number = 0xb7; // 183

  constructor(program: Program, cause?: Error) {
    super('Authority cannot apply all update args', program, cause);
  }
}
codeToErrorMap.set(0xb7, InvalidUpdateArgsError);
nameToErrorMap.set('InvalidUpdateArgs', InvalidUpdateArgsError);

/** InsufficientTokenBalance: Token account does not have enough tokens */
export class InsufficientTokenBalanceError extends ProgramError {
  readonly name: string = 'InsufficientTokenBalance';

  readonly code: number = 0xb8; // 184

  constructor(program: Program, cause?: Error) {
    super('Token account does not have enough tokens', program, cause);
  }
}
codeToErrorMap.set(0xb8, InsufficientTokenBalanceError);
nameToErrorMap.set('InsufficientTokenBalance', InsufficientTokenBalanceError);

/** MissingCollectionMint: Missing collection account */
export class MissingCollectionMintError extends ProgramError {
  readonly name: string = 'MissingCollectionMint';

  readonly code: number = 0xb9; // 185

  constructor(program: Program, cause?: Error) {
    super('Missing collection account', program, cause);
  }
}
codeToErrorMap.set(0xb9, MissingCollectionMintError);
nameToErrorMap.set('MissingCollectionMint', MissingCollectionMintError);

/** MissingCollectionMasterEdition: Missing collection master edition account */
export class MissingCollectionMasterEditionError extends ProgramError {
  readonly name: string = 'MissingCollectionMasterEdition';

  readonly code: number = 0xba; // 186

  constructor(program: Program, cause?: Error) {
    super('Missing collection master edition account', program, cause);
  }
}
codeToErrorMap.set(0xba, MissingCollectionMasterEditionError);
nameToErrorMap.set(
  'MissingCollectionMasterEdition',
  MissingCollectionMasterEditionError
);

/** InvalidTokenRecord: Invalid token record account */
export class InvalidTokenRecordError extends ProgramError {
  readonly name: string = 'InvalidTokenRecord';

  readonly code: number = 0xbb; // 187

  constructor(program: Program, cause?: Error) {
    super('Invalid token record account', program, cause);
  }
}
codeToErrorMap.set(0xbb, InvalidTokenRecordError);
nameToErrorMap.set('InvalidTokenRecord', InvalidTokenRecordError);

/** InvalidCloseAuthority: The close authority needs to be revoked by the Utility Delegate */
export class InvalidCloseAuthorityError extends ProgramError {
  readonly name: string = 'InvalidCloseAuthority';

  readonly code: number = 0xbc; // 188

  constructor(program: Program, cause?: Error) {
    super(
      'The close authority needs to be revoked by the Utility Delegate',
      program,
      cause
    );
  }
}
codeToErrorMap.set(0xbc, InvalidCloseAuthorityError);
nameToErrorMap.set('InvalidCloseAuthority', InvalidCloseAuthorityError);

/** InvalidInstruction: Invalid or removed instruction */
export class InvalidInstructionError extends ProgramError {
  readonly name: string = 'InvalidInstruction';

  readonly code: number = 0xbd; // 189

  constructor(program: Program, cause?: Error) {
    super('Invalid or removed instruction', program, cause);
  }
}
codeToErrorMap.set(0xbd, InvalidInstructionError);
nameToErrorMap.set('InvalidInstruction', InvalidInstructionError);

/** MissingDelegateRecord: Missing delegate record */
export class MissingDelegateRecordError extends ProgramError {
  readonly name: string = 'MissingDelegateRecord';

  readonly code: number = 0xbe; // 190

  constructor(program: Program, cause?: Error) {
    super('Missing delegate record', program, cause);
  }
}
codeToErrorMap.set(0xbe, MissingDelegateRecordError);
nameToErrorMap.set('MissingDelegateRecord', MissingDelegateRecordError);

/** InvalidFeeAccount */
export class InvalidFeeAccountError extends ProgramError {
  readonly name: string = 'InvalidFeeAccount';

  readonly code: number = 0xbf; // 191

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0xbf, InvalidFeeAccountError);
nameToErrorMap.set('InvalidFeeAccount', InvalidFeeAccountError);

/** InvalidMetadataFlags */
export class InvalidMetadataFlagsError extends ProgramError {
  readonly name: string = 'InvalidMetadataFlags';

  readonly code: number = 0xc0; // 192

  constructor(program: Program, cause?: Error) {
    super('', program, cause);
  }
}
codeToErrorMap.set(0xc0, InvalidMetadataFlagsError);
nameToErrorMap.set('InvalidMetadataFlags', InvalidMetadataFlagsError);

/** CannotChangeUpdateAuthorityWithDelegate: Cannot change the update authority with a delegate */
export class CannotChangeUpdateAuthorityWithDelegateError extends ProgramError {
  readonly name: string = 'CannotChangeUpdateAuthorityWithDelegate';

  readonly code: number = 0xc1; // 193

  constructor(program: Program, cause?: Error) {
    super('Cannot change the update authority with a delegate', program, cause);
  }
}
codeToErrorMap.set(0xc1, CannotChangeUpdateAuthorityWithDelegateError);
nameToErrorMap.set(
  'CannotChangeUpdateAuthorityWithDelegate',
  CannotChangeUpdateAuthorityWithDelegateError
);

/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 */
export function getMplTokenMetadataErrorFromCode(
  code: number,
  program: Program,
  cause?: Error
): ProgramError | null {
  const constructor = codeToErrorMap.get(code);
  return constructor ? new constructor(program, cause) : null;
}

/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 */
export function getMplTokenMetadataErrorFromName(
  name: string,
  program: Program,
  cause?: Error
): ProgramError | null {
  const constructor = nameToErrorMap.get(name);
  return constructor ? new constructor(program, cause) : null;
}
