/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/kit';
import {
  findAssociatedTokenPda,
  findEditionMarkerFromEditionNumberPda,
  findEditionMarkerV2Pda,
  findMasterEditionPda,
  findMetadataPda,
  findTokenRecordPda,
} from '../pdas';
import { MPL_TOKEN_METADATA_PROGRAM_ADDRESS } from '../programs';
import {
  expectAddress,
  expectSome,
  getAccountMetaFactory,
  type ResolvedAccount,
} from '../shared';
import { TokenStandard, type TokenStandardArgs } from '../types';

export const PRINT_V2_DISCRIMINATOR = 55;

export function getPrintV2DiscriminatorBytes() {
  return getU8Encoder().encode(PRINT_V2_DISCRIMINATOR);
}

export type PrintV2Instruction<
  TProgram extends string = typeof MPL_TOKEN_METADATA_PROGRAM_ADDRESS,
  TAccountEditionMetadata extends string | AccountMeta<string> = string,
  TAccountEdition extends string | AccountMeta<string> = string,
  TAccountEditionMint extends string | AccountMeta<string> = string,
  TAccountEditionTokenAccountOwner extends
    | string
    | AccountMeta<string> = string,
  TAccountEditionTokenAccount extends string | AccountMeta<string> = string,
  TAccountEditionMintAuthority extends string | AccountMeta<string> = string,
  TAccountEditionTokenRecord extends string | AccountMeta<string> = string,
  TAccountMasterEdition extends string | AccountMeta<string> = string,
  TAccountEditionMarkerPda extends string | AccountMeta<string> = string,
  TAccountPayer extends string | AccountMeta<string> = string,
  TAccountMasterTokenAccountOwner extends string | AccountMeta<string> = string,
  TAccountMasterTokenAccount extends string | AccountMeta<string> = string,
  TAccountMasterMetadata extends string | AccountMeta<string> = string,
  TAccountUpdateAuthority extends string | AccountMeta<string> = string,
  TAccountSplTokenProgram extends
    | string
    | AccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
  TAccountSplAtaProgram extends
    | string
    | AccountMeta<string> = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',
  TAccountSysvarInstructions extends
    | string
    | AccountMeta<string> = 'Sysvar1nstructions1111111111111111111111111',
  TAccountSystemProgram extends
    | string
    | AccountMeta<string> = '11111111111111111111111111111111',
  TAccountHolderDelegateRecord extends string | AccountMeta<string> = string,
  TAccountDelegate extends string | AccountMeta<string> = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountEditionMetadata extends string
        ? WritableAccount<TAccountEditionMetadata>
        : TAccountEditionMetadata,
      TAccountEdition extends string
        ? WritableAccount<TAccountEdition>
        : TAccountEdition,
      TAccountEditionMint extends string
        ? WritableAccount<TAccountEditionMint>
        : TAccountEditionMint,
      TAccountEditionTokenAccountOwner extends string
        ? ReadonlyAccount<TAccountEditionTokenAccountOwner>
        : TAccountEditionTokenAccountOwner,
      TAccountEditionTokenAccount extends string
        ? WritableAccount<TAccountEditionTokenAccount>
        : TAccountEditionTokenAccount,
      TAccountEditionMintAuthority extends string
        ? ReadonlySignerAccount<TAccountEditionMintAuthority> &
            AccountSignerMeta<TAccountEditionMintAuthority>
        : TAccountEditionMintAuthority,
      TAccountEditionTokenRecord extends string
        ? WritableAccount<TAccountEditionTokenRecord>
        : TAccountEditionTokenRecord,
      TAccountMasterEdition extends string
        ? WritableAccount<TAccountMasterEdition>
        : TAccountMasterEdition,
      TAccountEditionMarkerPda extends string
        ? WritableAccount<TAccountEditionMarkerPda>
        : TAccountEditionMarkerPda,
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountMasterTokenAccountOwner extends string
        ? ReadonlyAccount<TAccountMasterTokenAccountOwner>
        : TAccountMasterTokenAccountOwner,
      TAccountMasterTokenAccount extends string
        ? ReadonlyAccount<TAccountMasterTokenAccount>
        : TAccountMasterTokenAccount,
      TAccountMasterMetadata extends string
        ? ReadonlyAccount<TAccountMasterMetadata>
        : TAccountMasterMetadata,
      TAccountUpdateAuthority extends string
        ? ReadonlyAccount<TAccountUpdateAuthority>
        : TAccountUpdateAuthority,
      TAccountSplTokenProgram extends string
        ? ReadonlyAccount<TAccountSplTokenProgram>
        : TAccountSplTokenProgram,
      TAccountSplAtaProgram extends string
        ? ReadonlyAccount<TAccountSplAtaProgram>
        : TAccountSplAtaProgram,
      TAccountSysvarInstructions extends string
        ? ReadonlyAccount<TAccountSysvarInstructions>
        : TAccountSysvarInstructions,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountHolderDelegateRecord extends string
        ? ReadonlyAccount<TAccountHolderDelegateRecord>
        : TAccountHolderDelegateRecord,
      TAccountDelegate extends string
        ? ReadonlySignerAccount<TAccountDelegate> &
            AccountSignerMeta<TAccountDelegate>
        : TAccountDelegate,
      ...TRemainingAccounts,
    ]
  >;

export type PrintV2InstructionData = {
  discriminator: number;
  printV2Discriminator: number;
  editionNumber: bigint;
};

export type PrintV2InstructionDataArgs = { editionNumber: number | bigint };

export function getPrintV2InstructionDataEncoder(): FixedSizeEncoder<PrintV2InstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', getU8Encoder()],
      ['printV2Discriminator', getU8Encoder()],
      ['editionNumber', getU64Encoder()],
    ]),
    (value) => ({
      ...value,
      discriminator: PRINT_V2_DISCRIMINATOR,
      printV2Discriminator: 1,
    })
  );
}

export function getPrintV2InstructionDataDecoder(): FixedSizeDecoder<PrintV2InstructionData> {
  return getStructDecoder([
    ['discriminator', getU8Decoder()],
    ['printV2Discriminator', getU8Decoder()],
    ['editionNumber', getU64Decoder()],
  ]);
}

export function getPrintV2InstructionDataCodec(): FixedSizeCodec<
  PrintV2InstructionDataArgs,
  PrintV2InstructionData
> {
  return combineCodec(
    getPrintV2InstructionDataEncoder(),
    getPrintV2InstructionDataDecoder()
  );
}

export type PrintV2InstructionExtraArgs = {
  masterEditionMint: Address;
  tokenStandard: TokenStandardArgs;
};

export type PrintV2AsyncInput<
  TAccountEditionMetadata extends string = string,
  TAccountEdition extends string = string,
  TAccountEditionMint extends string = string,
  TAccountEditionTokenAccountOwner extends string = string,
  TAccountEditionTokenAccount extends string = string,
  TAccountEditionMintAuthority extends string = string,
  TAccountEditionTokenRecord extends string = string,
  TAccountMasterEdition extends string = string,
  TAccountEditionMarkerPda extends string = string,
  TAccountPayer extends string = string,
  TAccountMasterTokenAccountOwner extends string = string,
  TAccountMasterTokenAccount extends string = string,
  TAccountMasterMetadata extends string = string,
  TAccountUpdateAuthority extends string = string,
  TAccountSplTokenProgram extends string = string,
  TAccountSplAtaProgram extends string = string,
  TAccountSysvarInstructions extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountHolderDelegateRecord extends string = string,
  TAccountDelegate extends string = string,
> = {
  /** New Metadata key (pda of ['metadata', program id, mint id]) */
  editionMetadata?: Address<TAccountEditionMetadata>;
  /** New Edition (pda of ['metadata', program id, mint id, 'edition']) */
  edition?: Address<TAccountEdition>;
  /** Mint of new token - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY */
  editionMint:
    | Address<TAccountEditionMint>
    | TransactionSigner<TAccountEditionMint>;
  /** Owner of the token account of new token */
  editionTokenAccountOwner: Address<TAccountEditionTokenAccountOwner>;
  /** Token account of new token */
  editionTokenAccount?: Address<TAccountEditionTokenAccount>;
  /** Mint authority of new mint */
  editionMintAuthority?: TransactionSigner<TAccountEditionMintAuthority>;
  /** Token record account */
  editionTokenRecord?: Address<TAccountEditionTokenRecord>;
  /** Master Record Edition V2 (pda of ['metadata', program id, master metadata mint id, 'edition']) */
  masterEdition?: Address<TAccountMasterEdition>;
  /** Edition pda to mark creation - will be checked for pre-existence. (pda of ['metadata', program id, master metadata mint id, 'edition', edition_number]) where edition_number is NOT the edition number you pass in args but actually edition_number = floor(edition/EDITION_MARKER_BIT_SIZE). */
  editionMarkerPda?: Address<TAccountEditionMarkerPda>;
  /** payer */
  payer: TransactionSigner<TAccountPayer>;
  /** owner of token account containing master token */
  masterTokenAccountOwner?:
    | Address<TAccountMasterTokenAccountOwner>
    | TransactionSigner<TAccountMasterTokenAccountOwner>;
  /** token account containing token from master metadata mint */
  masterTokenAccount?: Address<TAccountMasterTokenAccount>;
  /** Master record metadata account */
  masterMetadata?: Address<TAccountMasterMetadata>;
  /** The update authority of the master edition. */
  updateAuthority: Address<TAccountUpdateAuthority>;
  /** Token program */
  splTokenProgram?: Address<TAccountSplTokenProgram>;
  /** SPL Associated Token Account program */
  splAtaProgram?: Address<TAccountSplAtaProgram>;
  /** Instructions sysvar account */
  sysvarInstructions?: Address<TAccountSysvarInstructions>;
  /** System program */
  systemProgram?: Address<TAccountSystemProgram>;
  /** The Delegate Record authorizing escrowless edition printing */
  holderDelegateRecord?: Address<TAccountHolderDelegateRecord>;
  /** The authority printing the edition for a delegated print */
  delegate?: TransactionSigner<TAccountDelegate>;
  editionNumber: PrintV2InstructionDataArgs['editionNumber'];
  masterEditionMint: PrintV2InstructionExtraArgs['masterEditionMint'];
  tokenStandard: PrintV2InstructionExtraArgs['tokenStandard'];
};

export async function getPrintV2InstructionAsync<
  TAccountEditionMetadata extends string,
  TAccountEdition extends string,
  TAccountEditionMint extends string,
  TAccountEditionTokenAccountOwner extends string,
  TAccountEditionTokenAccount extends string,
  TAccountEditionMintAuthority extends string,
  TAccountEditionTokenRecord extends string,
  TAccountMasterEdition extends string,
  TAccountEditionMarkerPda extends string,
  TAccountPayer extends string,
  TAccountMasterTokenAccountOwner extends string,
  TAccountMasterTokenAccount extends string,
  TAccountMasterMetadata extends string,
  TAccountUpdateAuthority extends string,
  TAccountSplTokenProgram extends string,
  TAccountSplAtaProgram extends string,
  TAccountSysvarInstructions extends string,
  TAccountSystemProgram extends string,
  TAccountHolderDelegateRecord extends string,
  TAccountDelegate extends string,
  TProgramAddress extends Address = typeof MPL_TOKEN_METADATA_PROGRAM_ADDRESS,
>(
  input: PrintV2AsyncInput<
    TAccountEditionMetadata,
    TAccountEdition,
    TAccountEditionMint,
    TAccountEditionTokenAccountOwner,
    TAccountEditionTokenAccount,
    TAccountEditionMintAuthority,
    TAccountEditionTokenRecord,
    TAccountMasterEdition,
    TAccountEditionMarkerPda,
    TAccountPayer,
    TAccountMasterTokenAccountOwner,
    TAccountMasterTokenAccount,
    TAccountMasterMetadata,
    TAccountUpdateAuthority,
    TAccountSplTokenProgram,
    TAccountSplAtaProgram,
    TAccountSysvarInstructions,
    TAccountSystemProgram,
    TAccountHolderDelegateRecord,
    TAccountDelegate
  >,
  config?: { programAddress?: TProgramAddress }
): Promise<
  PrintV2Instruction<
    TProgramAddress,
    TAccountEditionMetadata,
    TAccountEdition,
    (typeof input)['editionMint'] extends TransactionSigner<TAccountEditionMint>
      ? WritableSignerAccount<TAccountEditionMint> &
          AccountSignerMeta<TAccountEditionMint>
      : TAccountEditionMint,
    TAccountEditionTokenAccountOwner,
    TAccountEditionTokenAccount,
    TAccountEditionMintAuthority,
    TAccountEditionTokenRecord,
    TAccountMasterEdition,
    TAccountEditionMarkerPda,
    TAccountPayer,
    (typeof input)['masterTokenAccountOwner'] extends TransactionSigner<TAccountMasterTokenAccountOwner>
      ? ReadonlySignerAccount<TAccountMasterTokenAccountOwner> &
          AccountSignerMeta<TAccountMasterTokenAccountOwner>
      : TAccountMasterTokenAccountOwner,
    TAccountMasterTokenAccount,
    TAccountMasterMetadata,
    TAccountUpdateAuthority,
    TAccountSplTokenProgram,
    TAccountSplAtaProgram,
    TAccountSysvarInstructions,
    TAccountSystemProgram,
    TAccountHolderDelegateRecord,
    TAccountDelegate
  >
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? MPL_TOKEN_METADATA_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    editionMetadata: { value: input.editionMetadata ?? null, isWritable: true },
    edition: { value: input.edition ?? null, isWritable: true },
    editionMint: { value: input.editionMint ?? null, isWritable: true },
    editionTokenAccountOwner: {
      value: input.editionTokenAccountOwner ?? null,
      isWritable: false,
    },
    editionTokenAccount: {
      value: input.editionTokenAccount ?? null,
      isWritable: true,
    },
    editionMintAuthority: {
      value: input.editionMintAuthority ?? null,
      isWritable: false,
    },
    editionTokenRecord: {
      value: input.editionTokenRecord ?? null,
      isWritable: true,
    },
    masterEdition: { value: input.masterEdition ?? null, isWritable: true },
    editionMarkerPda: {
      value: input.editionMarkerPda ?? null,
      isWritable: true,
    },
    payer: { value: input.payer ?? null, isWritable: true },
    masterTokenAccountOwner: {
      value: input.masterTokenAccountOwner ?? null,
      isWritable: false,
    },
    masterTokenAccount: {
      value: input.masterTokenAccount ?? null,
      isWritable: false,
    },
    masterMetadata: { value: input.masterMetadata ?? null, isWritable: false },
    updateAuthority: {
      value: input.updateAuthority ?? null,
      isWritable: false,
    },
    splTokenProgram: {
      value: input.splTokenProgram ?? null,
      isWritable: false,
    },
    splAtaProgram: { value: input.splAtaProgram ?? null, isWritable: false },
    sysvarInstructions: {
      value: input.sysvarInstructions ?? null,
      isWritable: false,
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    holderDelegateRecord: {
      value: input.holderDelegateRecord ?? null,
      isWritable: false,
    },
    delegate: { value: input.delegate ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.editionMetadata.value) {
    accounts.editionMetadata.value = await findMetadataPda({
      mint: expectAddress(accounts.editionMint.value),
    });
  }
  if (!accounts.edition.value) {
    accounts.edition.value = await findMasterEditionPda({
      mint: expectAddress(accounts.editionMint.value),
    });
  }
  if (!accounts.editionTokenAccount.value) {
    accounts.editionTokenAccount.value = await findAssociatedTokenPda({
      mint: expectAddress(accounts.editionMint.value),
      owner: expectAddress(accounts.editionTokenAccountOwner.value),
    });
  }
  if (!accounts.editionMintAuthority.value) {
    if (accounts.holderDelegateRecord.value) {
      if (accounts.delegate.value) {
        accounts.editionMintAuthority.value = expectSome(
          accounts.delegate.value
        );
      } else {
        accounts.editionMintAuthority.value = expectSome(accounts.payer.value);
      }
    } else {
    }
  }
  if (!accounts.editionTokenRecord.value) {
    if (args.tokenStandard === TokenStandard.ProgrammableNonFungible) {
      accounts.editionTokenRecord.value = await findTokenRecordPda({
        mint: expectAddress(accounts.editionMint.value),
        token: expectAddress(accounts.editionTokenAccount.value),
      });
    }
  }
  if (!accounts.masterEdition.value) {
    accounts.masterEdition.value = await findMasterEditionPda({
      mint: expectSome(args.masterEditionMint),
    });
  }
  if (!accounts.editionMarkerPda.value) {
    if (args.tokenStandard === TokenStandard.ProgrammableNonFungible) {
      accounts.editionMarkerPda.value = await findEditionMarkerV2Pda({
        mint: expectSome(args.masterEditionMint),
      });
    } else {
      accounts.editionMarkerPda.value =
        await findEditionMarkerFromEditionNumberPda({
          mint: expectSome(args.masterEditionMint),
          editionNumber: expectSome(args.editionNumber),
        });
    }
  }
  if (!accounts.masterTokenAccountOwner.value) {
    if (!accounts.holderDelegateRecord.value) {
    }
  }
  if (!accounts.masterTokenAccount.value) {
    accounts.masterTokenAccount.value = await findAssociatedTokenPda({
      mint: expectSome(args.masterEditionMint),
      owner: expectAddress(accounts.masterTokenAccountOwner.value),
    });
  }
  if (!accounts.masterMetadata.value) {
    accounts.masterMetadata.value = await findMetadataPda({
      mint: expectSome(args.masterEditionMint),
    });
  }
  if (!accounts.splTokenProgram.value) {
    accounts.splTokenProgram.value =
      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
  }
  if (!accounts.splAtaProgram.value) {
    accounts.splAtaProgram.value =
      'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;
  }
  if (!accounts.sysvarInstructions.value) {
    accounts.sysvarInstructions.value =
      'Sysvar1nstructions1111111111111111111111111' as Address<'Sysvar1nstructions1111111111111111111111111'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.editionMetadata),
      getAccountMeta(accounts.edition),
      getAccountMeta(accounts.editionMint),
      getAccountMeta(accounts.editionTokenAccountOwner),
      getAccountMeta(accounts.editionTokenAccount),
      getAccountMeta(accounts.editionMintAuthority),
      getAccountMeta(accounts.editionTokenRecord),
      getAccountMeta(accounts.masterEdition),
      getAccountMeta(accounts.editionMarkerPda),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.masterTokenAccountOwner),
      getAccountMeta(accounts.masterTokenAccount),
      getAccountMeta(accounts.masterMetadata),
      getAccountMeta(accounts.updateAuthority),
      getAccountMeta(accounts.splTokenProgram),
      getAccountMeta(accounts.splAtaProgram),
      getAccountMeta(accounts.sysvarInstructions),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.holderDelegateRecord),
      getAccountMeta(accounts.delegate),
    ],
    programAddress,
    data: getPrintV2InstructionDataEncoder().encode(
      args as PrintV2InstructionDataArgs
    ),
  } as PrintV2Instruction<
    TProgramAddress,
    TAccountEditionMetadata,
    TAccountEdition,
    (typeof input)['editionMint'] extends TransactionSigner<TAccountEditionMint>
      ? WritableSignerAccount<TAccountEditionMint> &
          AccountSignerMeta<TAccountEditionMint>
      : TAccountEditionMint,
    TAccountEditionTokenAccountOwner,
    TAccountEditionTokenAccount,
    TAccountEditionMintAuthority,
    TAccountEditionTokenRecord,
    TAccountMasterEdition,
    TAccountEditionMarkerPda,
    TAccountPayer,
    (typeof input)['masterTokenAccountOwner'] extends TransactionSigner<TAccountMasterTokenAccountOwner>
      ? ReadonlySignerAccount<TAccountMasterTokenAccountOwner> &
          AccountSignerMeta<TAccountMasterTokenAccountOwner>
      : TAccountMasterTokenAccountOwner,
    TAccountMasterTokenAccount,
    TAccountMasterMetadata,
    TAccountUpdateAuthority,
    TAccountSplTokenProgram,
    TAccountSplAtaProgram,
    TAccountSysvarInstructions,
    TAccountSystemProgram,
    TAccountHolderDelegateRecord,
    TAccountDelegate
  >;

  return instruction;
}

export type PrintV2Input<
  TAccountEditionMetadata extends string = string,
  TAccountEdition extends string = string,
  TAccountEditionMint extends string = string,
  TAccountEditionTokenAccountOwner extends string = string,
  TAccountEditionTokenAccount extends string = string,
  TAccountEditionMintAuthority extends string = string,
  TAccountEditionTokenRecord extends string = string,
  TAccountMasterEdition extends string = string,
  TAccountEditionMarkerPda extends string = string,
  TAccountPayer extends string = string,
  TAccountMasterTokenAccountOwner extends string = string,
  TAccountMasterTokenAccount extends string = string,
  TAccountMasterMetadata extends string = string,
  TAccountUpdateAuthority extends string = string,
  TAccountSplTokenProgram extends string = string,
  TAccountSplAtaProgram extends string = string,
  TAccountSysvarInstructions extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountHolderDelegateRecord extends string = string,
  TAccountDelegate extends string = string,
> = {
  /** New Metadata key (pda of ['metadata', program id, mint id]) */
  editionMetadata: Address<TAccountEditionMetadata>;
  /** New Edition (pda of ['metadata', program id, mint id, 'edition']) */
  edition: Address<TAccountEdition>;
  /** Mint of new token - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY */
  editionMint:
    | Address<TAccountEditionMint>
    | TransactionSigner<TAccountEditionMint>;
  /** Owner of the token account of new token */
  editionTokenAccountOwner: Address<TAccountEditionTokenAccountOwner>;
  /** Token account of new token */
  editionTokenAccount: Address<TAccountEditionTokenAccount>;
  /** Mint authority of new mint */
  editionMintAuthority?: TransactionSigner<TAccountEditionMintAuthority>;
  /** Token record account */
  editionTokenRecord?: Address<TAccountEditionTokenRecord>;
  /** Master Record Edition V2 (pda of ['metadata', program id, master metadata mint id, 'edition']) */
  masterEdition: Address<TAccountMasterEdition>;
  /** Edition pda to mark creation - will be checked for pre-existence. (pda of ['metadata', program id, master metadata mint id, 'edition', edition_number]) where edition_number is NOT the edition number you pass in args but actually edition_number = floor(edition/EDITION_MARKER_BIT_SIZE). */
  editionMarkerPda: Address<TAccountEditionMarkerPda>;
  /** payer */
  payer: TransactionSigner<TAccountPayer>;
  /** owner of token account containing master token */
  masterTokenAccountOwner?:
    | Address<TAccountMasterTokenAccountOwner>
    | TransactionSigner<TAccountMasterTokenAccountOwner>;
  /** token account containing token from master metadata mint */
  masterTokenAccount: Address<TAccountMasterTokenAccount>;
  /** Master record metadata account */
  masterMetadata: Address<TAccountMasterMetadata>;
  /** The update authority of the master edition. */
  updateAuthority: Address<TAccountUpdateAuthority>;
  /** Token program */
  splTokenProgram?: Address<TAccountSplTokenProgram>;
  /** SPL Associated Token Account program */
  splAtaProgram?: Address<TAccountSplAtaProgram>;
  /** Instructions sysvar account */
  sysvarInstructions?: Address<TAccountSysvarInstructions>;
  /** System program */
  systemProgram?: Address<TAccountSystemProgram>;
  /** The Delegate Record authorizing escrowless edition printing */
  holderDelegateRecord?: Address<TAccountHolderDelegateRecord>;
  /** The authority printing the edition for a delegated print */
  delegate?: TransactionSigner<TAccountDelegate>;
  editionNumber: PrintV2InstructionDataArgs['editionNumber'];
  masterEditionMint: PrintV2InstructionExtraArgs['masterEditionMint'];
  tokenStandard: PrintV2InstructionExtraArgs['tokenStandard'];
};

export function getPrintV2Instruction<
  TAccountEditionMetadata extends string,
  TAccountEdition extends string,
  TAccountEditionMint extends string,
  TAccountEditionTokenAccountOwner extends string,
  TAccountEditionTokenAccount extends string,
  TAccountEditionMintAuthority extends string,
  TAccountEditionTokenRecord extends string,
  TAccountMasterEdition extends string,
  TAccountEditionMarkerPda extends string,
  TAccountPayer extends string,
  TAccountMasterTokenAccountOwner extends string,
  TAccountMasterTokenAccount extends string,
  TAccountMasterMetadata extends string,
  TAccountUpdateAuthority extends string,
  TAccountSplTokenProgram extends string,
  TAccountSplAtaProgram extends string,
  TAccountSysvarInstructions extends string,
  TAccountSystemProgram extends string,
  TAccountHolderDelegateRecord extends string,
  TAccountDelegate extends string,
  TProgramAddress extends Address = typeof MPL_TOKEN_METADATA_PROGRAM_ADDRESS,
>(
  input: PrintV2Input<
    TAccountEditionMetadata,
    TAccountEdition,
    TAccountEditionMint,
    TAccountEditionTokenAccountOwner,
    TAccountEditionTokenAccount,
    TAccountEditionMintAuthority,
    TAccountEditionTokenRecord,
    TAccountMasterEdition,
    TAccountEditionMarkerPda,
    TAccountPayer,
    TAccountMasterTokenAccountOwner,
    TAccountMasterTokenAccount,
    TAccountMasterMetadata,
    TAccountUpdateAuthority,
    TAccountSplTokenProgram,
    TAccountSplAtaProgram,
    TAccountSysvarInstructions,
    TAccountSystemProgram,
    TAccountHolderDelegateRecord,
    TAccountDelegate
  >,
  config?: { programAddress?: TProgramAddress }
): PrintV2Instruction<
  TProgramAddress,
  TAccountEditionMetadata,
  TAccountEdition,
  (typeof input)['editionMint'] extends TransactionSigner<TAccountEditionMint>
    ? WritableSignerAccount<TAccountEditionMint> &
        AccountSignerMeta<TAccountEditionMint>
    : TAccountEditionMint,
  TAccountEditionTokenAccountOwner,
  TAccountEditionTokenAccount,
  TAccountEditionMintAuthority,
  TAccountEditionTokenRecord,
  TAccountMasterEdition,
  TAccountEditionMarkerPda,
  TAccountPayer,
  (typeof input)['masterTokenAccountOwner'] extends TransactionSigner<TAccountMasterTokenAccountOwner>
    ? ReadonlySignerAccount<TAccountMasterTokenAccountOwner> &
        AccountSignerMeta<TAccountMasterTokenAccountOwner>
    : TAccountMasterTokenAccountOwner,
  TAccountMasterTokenAccount,
  TAccountMasterMetadata,
  TAccountUpdateAuthority,
  TAccountSplTokenProgram,
  TAccountSplAtaProgram,
  TAccountSysvarInstructions,
  TAccountSystemProgram,
  TAccountHolderDelegateRecord,
  TAccountDelegate
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? MPL_TOKEN_METADATA_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    editionMetadata: { value: input.editionMetadata ?? null, isWritable: true },
    edition: { value: input.edition ?? null, isWritable: true },
    editionMint: { value: input.editionMint ?? null, isWritable: true },
    editionTokenAccountOwner: {
      value: input.editionTokenAccountOwner ?? null,
      isWritable: false,
    },
    editionTokenAccount: {
      value: input.editionTokenAccount ?? null,
      isWritable: true,
    },
    editionMintAuthority: {
      value: input.editionMintAuthority ?? null,
      isWritable: false,
    },
    editionTokenRecord: {
      value: input.editionTokenRecord ?? null,
      isWritable: true,
    },
    masterEdition: { value: input.masterEdition ?? null, isWritable: true },
    editionMarkerPda: {
      value: input.editionMarkerPda ?? null,
      isWritable: true,
    },
    payer: { value: input.payer ?? null, isWritable: true },
    masterTokenAccountOwner: {
      value: input.masterTokenAccountOwner ?? null,
      isWritable: false,
    },
    masterTokenAccount: {
      value: input.masterTokenAccount ?? null,
      isWritable: false,
    },
    masterMetadata: { value: input.masterMetadata ?? null, isWritable: false },
    updateAuthority: {
      value: input.updateAuthority ?? null,
      isWritable: false,
    },
    splTokenProgram: {
      value: input.splTokenProgram ?? null,
      isWritable: false,
    },
    splAtaProgram: { value: input.splAtaProgram ?? null, isWritable: false },
    sysvarInstructions: {
      value: input.sysvarInstructions ?? null,
      isWritable: false,
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    holderDelegateRecord: {
      value: input.holderDelegateRecord ?? null,
      isWritable: false,
    },
    delegate: { value: input.delegate ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.editionMintAuthority.value) {
    if (accounts.holderDelegateRecord.value) {
      if (accounts.delegate.value) {
        accounts.editionMintAuthority.value = expectSome(
          accounts.delegate.value
        );
      } else {
        accounts.editionMintAuthority.value = expectSome(accounts.payer.value);
      }
    } else {
    }
  }
  if (!accounts.masterTokenAccountOwner.value) {
    if (!accounts.holderDelegateRecord.value) {
    }
  }
  if (!accounts.splTokenProgram.value) {
    accounts.splTokenProgram.value =
      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
  }
  if (!accounts.splAtaProgram.value) {
    accounts.splAtaProgram.value =
      'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;
  }
  if (!accounts.sysvarInstructions.value) {
    accounts.sysvarInstructions.value =
      'Sysvar1nstructions1111111111111111111111111' as Address<'Sysvar1nstructions1111111111111111111111111'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.editionMetadata),
      getAccountMeta(accounts.edition),
      getAccountMeta(accounts.editionMint),
      getAccountMeta(accounts.editionTokenAccountOwner),
      getAccountMeta(accounts.editionTokenAccount),
      getAccountMeta(accounts.editionMintAuthority),
      getAccountMeta(accounts.editionTokenRecord),
      getAccountMeta(accounts.masterEdition),
      getAccountMeta(accounts.editionMarkerPda),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.masterTokenAccountOwner),
      getAccountMeta(accounts.masterTokenAccount),
      getAccountMeta(accounts.masterMetadata),
      getAccountMeta(accounts.updateAuthority),
      getAccountMeta(accounts.splTokenProgram),
      getAccountMeta(accounts.splAtaProgram),
      getAccountMeta(accounts.sysvarInstructions),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.holderDelegateRecord),
      getAccountMeta(accounts.delegate),
    ],
    programAddress,
    data: getPrintV2InstructionDataEncoder().encode(
      args as PrintV2InstructionDataArgs
    ),
  } as PrintV2Instruction<
    TProgramAddress,
    TAccountEditionMetadata,
    TAccountEdition,
    (typeof input)['editionMint'] extends TransactionSigner<TAccountEditionMint>
      ? WritableSignerAccount<TAccountEditionMint> &
          AccountSignerMeta<TAccountEditionMint>
      : TAccountEditionMint,
    TAccountEditionTokenAccountOwner,
    TAccountEditionTokenAccount,
    TAccountEditionMintAuthority,
    TAccountEditionTokenRecord,
    TAccountMasterEdition,
    TAccountEditionMarkerPda,
    TAccountPayer,
    (typeof input)['masterTokenAccountOwner'] extends TransactionSigner<TAccountMasterTokenAccountOwner>
      ? ReadonlySignerAccount<TAccountMasterTokenAccountOwner> &
          AccountSignerMeta<TAccountMasterTokenAccountOwner>
      : TAccountMasterTokenAccountOwner,
    TAccountMasterTokenAccount,
    TAccountMasterMetadata,
    TAccountUpdateAuthority,
    TAccountSplTokenProgram,
    TAccountSplAtaProgram,
    TAccountSysvarInstructions,
    TAccountSystemProgram,
    TAccountHolderDelegateRecord,
    TAccountDelegate
  >;

  return instruction;
}

export type ParsedPrintV2Instruction<
  TProgram extends string = typeof MPL_TOKEN_METADATA_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /** New Metadata key (pda of ['metadata', program id, mint id]) */
    editionMetadata: TAccountMetas[0];
    /** New Edition (pda of ['metadata', program id, mint id, 'edition']) */
    edition: TAccountMetas[1];
    /** Mint of new token - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY */
    editionMint: TAccountMetas[2];
    /** Owner of the token account of new token */
    editionTokenAccountOwner: TAccountMetas[3];
    /** Token account of new token */
    editionTokenAccount: TAccountMetas[4];
    /** Mint authority of new mint */
    editionMintAuthority: TAccountMetas[5];
    /** Token record account */
    editionTokenRecord?: TAccountMetas[6] | undefined;
    /** Master Record Edition V2 (pda of ['metadata', program id, master metadata mint id, 'edition']) */
    masterEdition: TAccountMetas[7];
    /** Edition pda to mark creation - will be checked for pre-existence. (pda of ['metadata', program id, master metadata mint id, 'edition', edition_number]) where edition_number is NOT the edition number you pass in args but actually edition_number = floor(edition/EDITION_MARKER_BIT_SIZE). */
    editionMarkerPda: TAccountMetas[8];
    /** payer */
    payer: TAccountMetas[9];
    /** owner of token account containing master token */
    masterTokenAccountOwner: TAccountMetas[10];
    /** token account containing token from master metadata mint */
    masterTokenAccount: TAccountMetas[11];
    /** Master record metadata account */
    masterMetadata: TAccountMetas[12];
    /** The update authority of the master edition. */
    updateAuthority: TAccountMetas[13];
    /** Token program */
    splTokenProgram: TAccountMetas[14];
    /** SPL Associated Token Account program */
    splAtaProgram: TAccountMetas[15];
    /** Instructions sysvar account */
    sysvarInstructions: TAccountMetas[16];
    /** System program */
    systemProgram: TAccountMetas[17];
    /** The Delegate Record authorizing escrowless edition printing */
    holderDelegateRecord?: TAccountMetas[18] | undefined;
    /** The authority printing the edition for a delegated print */
    delegate?: TAccountMetas[19] | undefined;
  };
  data: PrintV2InstructionData;
};

export function parsePrintV2Instruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedPrintV2Instruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 20) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  const getNextOptionalAccount = () => {
    const accountMeta = getNextAccount();
    return accountMeta.address === MPL_TOKEN_METADATA_PROGRAM_ADDRESS
      ? undefined
      : accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      editionMetadata: getNextAccount(),
      edition: getNextAccount(),
      editionMint: getNextAccount(),
      editionTokenAccountOwner: getNextAccount(),
      editionTokenAccount: getNextAccount(),
      editionMintAuthority: getNextAccount(),
      editionTokenRecord: getNextOptionalAccount(),
      masterEdition: getNextAccount(),
      editionMarkerPda: getNextAccount(),
      payer: getNextAccount(),
      masterTokenAccountOwner: getNextAccount(),
      masterTokenAccount: getNextAccount(),
      masterMetadata: getNextAccount(),
      updateAuthority: getNextAccount(),
      splTokenProgram: getNextAccount(),
      splAtaProgram: getNextAccount(),
      sysvarInstructions: getNextAccount(),
      systemProgram: getNextAccount(),
      holderDelegateRecord: getNextOptionalAccount(),
      delegate: getNextOptionalAccount(),
    },
    data: getPrintV2InstructionDataDecoder().decode(instruction.data),
  };
}
